% !TEX root = omar-thesis.tex
\chapter{Unparameterized Expression TSMs}\label{chap:tsms}
We now introduce a new primitive -- the \textbf{typed syntax macro} (TSM) -- that combines much of the syntactic flexibility of syntax extensions with the reasoning guarantees of typed macros. This chapter focuses on TSMs that generate expressions of a single specified type (\emph{unparameterized expression TSMs}). We will add pattern matching in Chapter \ref{sec:pattern-tsms} and parameterized families of types in Chapter \ref{sec:tsms-parameterized}.

We begin in Sec. \ref{sec:tsms-by-example} by describing expression TSMs in VerseML by example.  In particular, we will show a TSM for introducing values of the type \li{Rx} defined in Figure \ref{fig:datatype-rx}. We will then discuss examples of TSMs that are useful for defining other TSMs in Sec. \ref{sec:tsms-for-tsms}. Finally, we will formally specify unparameterized expression TSMs with a lambda calculus, $\LTSM$, in Sec. \ref{sec:tsms-minimal-formalism}.% As we will discuss in the remainder of this section, this addresses the problems , at moderate syntactic cost.


%Like the term-rewriting macros just described, TSMs can be parameterized by modules, so they can be used to define syntax valid at any abstract type defined by a module satisfying a specified signature. As we will discuss in the remainder of this section, this addresses all of the problems brought up above, at moderate syntactic cost.

\section{Expression TSMs By Example}\label{sec:tsms-by-example}
%A typed syntax macro is invoked by applying it to a \emph{delimited form}, which can contain  arbitrary syntax in its \emph{body}.  

\subsection{Usage}\label{sec:uetsms-usage}
Consider the following VerseML expression:
\begin{lstlisting}[numbers=none,mathescape=|]
$rx /SURLA|T|G|CEURL/
\end{lstlisting}

Here, we apply a {TSM}, identified as \lstinline{#\dolla#rx}, 
to a \emph{literal form}, \lstinline{/SURLA|T|G|CEURL/}. 
The TSM statically parses the \emph{body} of the provided literal form, i.e. the characters in blue, to generate a \emph{candidate expansion}. The language then \emph{validates} the candidate expansion to maintain a type and hygiene discipline, in a manner that we will describe in Sec. \ref{sec:uetsms-validation}, before producing the \emph{final expansion}. The final expansion of the expression above, written concretely, is:
\begin{lstlisting}[numbers=none]
Or(Str "SSTRAESTR", Or(Str "SSTRTESTR", Or(Str "SSTRGESTR", Str "SSTRCESTR")))
\end{lstlisting}
The constructors in the expansion above are those of the type \li{Rx} defined in Fig. \ref{fig:datatype-rx}.

A number of literal forms, shown in Figure \ref{fig:literal-forms},  are available in VerseML's concrete syntax. Though certain TSMs may by convention call for the use of particular literal forms, any literal form can be used with any TSM, e.g. we could have written \lstinline{#\dolla#rx `SURLA|T|G|CEURL`} above (this would actually be convenient if we wanted to write a regex containing forward slashes but not backticks). %The form does not directly determine the expansion. 

\begin{figure}
\begin{lstlisting}
'SURLbody cannot contain an apostropheEURL'
`SURLbody cannot contain a backtickEURL`
[SURLbody cannot contain unmatched square bracketsEURL]
{SURLbody cannot contain an unmatched curly braceEURL}
/SURLbody cannot contain a forward slashEURL/
\SURLbody cannot contain a backslashEURL\
SURL42EURL (* numeric forms *)
SURL42pxEURL (* numeric forms with suffixes *)
\end{lstlisting}
%SURL<tag>body includes enclosing tags</tag>EURL
\caption[Available Literal Forms]{Literal forms available for use with TSMs in VerseML's concrete syntax. The characters in blue are the bodies of each form. In this figure, each line describes how the body is constrained by the form shown on that line. The Wyvern language specifies additional forms, including whitespace-delimited forms \cite{TSLs} and multipart forms \cite{sac15}, but for simplicity we leave these out of VerseML.}
\label{fig:literal-forms}
\end{figure}
\subsection{Definition}\label{sec:uetsms-definition}
%The original expression, above, is statically rewritten to this expression.
The definition of the TSM \lstinline{#\dolla#rx} shown in use above has the following form:
\begin{lstlisting}[numbers=none,mathescape=|]
syntax $rx at Rx {
  static fn(body : Body) : ParseResult => (* regex literal parser here *)
}
\end{lstlisting}
This {TSM definition} first identifies the TSM as \lstinline{#\dolla#rx}, then specifies a \emph{type annotation}, \lstinline{at Rx}, and a \emph{parse function}, within curly braces. 

VerseML enforces the convention that all TSM identifiers must be prefixed with a dollar sign (though other language designs could choose not to do so). 

The {parse function} is a \emph{static function} that generates an encoding of the candidate expansion, or indicates an error if a candidate expansion can't be generated (i.e. there is a parse error).  Static functions are functions written in a static subset of the language, called the \emph{static language} (SL). We will return to the design space around the static language in Sec. \ref{sec:static-subset}. The parse function has type \li{Body -> ParseResult}. These types are defined in the VerseML \emph{prelude}, which is a set of definitions available ambiently. The input type, \lstinline{Body}, gives the parse function access to the {body} of the provided literal form, which can be represented as a string:
\begin{lstlisting}[numbers=none]
type Body = string
\end{lstlisting} 

The output type, \li{ParseResult}, distinguishes between successful parses and parse errors:
\begin{lstlisting}[numbers=none]
type ParseResult = Success of CandidateExp 
                 | ParseError of {errorMsg : string, errorLoc : IndexRange}
\end{lstlisting}

Successful parses, constructed by \li{Success}, generate candidate expansions, which are encoded as values of type \lstinline{CandidateExp}:
\begin{lstlisting}[numbers=none]
type CandidateExp = Var of var_t | ... | Spliced of IndexRange
\end{lstlisting}
The elided constructors above simply encode the abstract syntax of the VerseML expression language (as in the SML visible compiler \cite{SML/VisibleCompiler}). We will discuss the final constructor, \li{Spliced}, in Sec. \ref{sec:splicing-and-hygiene}. We will show a complete encoding when we describe our reduced formal system $\LTSM$ in Sec. \ref{sec:tsms-minimal-formalism}. We define \li{CandidateExp} as  a recursive labeled sum type for simplicity here, but alternative encodings of abstract syntax, e.g. based on abstract binding trees \cite{pfpl}, could also have been chosen with only minor modification to the semantics. % It is extended with one additional form used to handled spliced subexpressions, 

If a parse error is detected, the parse function returns a value constructed by \li{ParseError}. The TSM provider must provide an error message (as a \li{string}) and indicate the location of the error relative to the body of the literal form as an index range, of type \li{IndexRange}:
\begin{lstlisting}[numbers=none]
type IndexRange = {startIndex : nat, endIndex : nat} (* inclusive *)
\end{lstlisting}
The error message and error location can be used by VerseML compilers when reporting errors to the programmer.

%Notice that the types just described are those that one would expect to find in a typical parser.

%One would find types analagous to those just described in any parser, so for concision, we elide the details of \li{#\dolla#rx}'s parse function.
%The parse function must treat the TSM parameters parametrically, i.e. it does not have access to any values in the supplied module parameter. Only the expansion the parse function generates can refer to module parameters. 
%For example, the following definition is ill-sorted:
%\begin{lstlisting}[numbers=none]
%syntax pattern_bad[Q : PATTERN] at Q.t {
%  static fn (body : Body) : Exp => 
%    if Q.flag then (* ... *) else (* ... *)
%}
%\end{lstlisting}%So the parse function parses the body of the delimited form to generate an encoding of the elaboration.

\subsection{Splicing}\label{sec:splicing-and-hygiene}
To support spliced subexpressions, like we described in Sec. \ref{sec:syntax-examples-regexps}, the parse function must be able to parse subexpressions out of the supplied literal body. For example, consider the code snippet in Figure \ref{fig:derived-spliced-subexpressions}, rewritten using the \li{#\dolla#rx} TSM:
\begin{lstlisting}[numbers=none]
val ssn = $rx /SURL\d\d\d-\d\d-\d\d\d\dEURL/
fun example_rx_tsm(name: string) => $rx /SURL@EURLnameSURL: %EURLssn/
\end{lstlisting}
The subexpressions \lstinline{name} and \lstinline{ssn} on the second line appear directly in the body of the literal form, so we call them \emph{spliced subexpressions}. When the parse function determines that a subsequence of the body should be treated as a spliced subexpression (here, by recognizing the characters \lstinline{@} or \lstinline{%} followed by a variable or parenthesized expression), 
it can mark this subsequence as such and use it within the expansion it generates using the \li{Spliced} constructor of the \li{CandidateExp} type shown above. Notice that spliced subexpressions are referred to indirectly by their position within the literal body (i.e. with a value of type \li{IndexRange}, shown above) to prevent TSMs from forging a spliced subexpression (i.e. claiming that an expression is a spliced subexpression, even though it does not appear in the body of the literal form). %In particular, the parse function must provide the index range of spliced subexpressions to the \li{Spliced} constructor of the type \li{MarkedExp}. %Only subexpressions that actually appear in the body of the literal form can be marked as spliced subexpressions.

The candidate expansion generated by \li{#\dolla#rx} for the body of \lstinline{example_rx_tsm}, if written in a hypothetical concrete syntax for candidate expansions where spliced subexpressions are written \li{spliced<startIdx, endIndex>}, is:
\begin{lstlisting}[numbers=none]
Seq(Str(spliced<1, 4>), Seq(Str "SSTR: ESTR", spliced<8, 10>))
\end{lstlisting}
Here, \li{spliced<1, 4>} refers to the subexpression \li{name} by position and \li{spliced<8, 10>} refers to the subexpression \li{ssn} by position. 

%For example, had the  would not be a valid expansion, because the  that are not inside spliced subexpressions:
%\begin{lstlisting}[numbers=none]
%Q.Seq(Q.Str(name), Q.Seq(Q.Str ": ", ssn))
%\end{lstlisting}

\subsection{Validation}\label{sec:uetsms-validation}
The language \emph{validates} candidate expansions to ensure that they are \emph{well-typed} and \emph{hygienic}. 

\subsubsection{Typing}
The type annotation specified by the TSM, i.e. the type \li{Rx} in the example above, determines the type that the candidate expansion is checked against. This maintains a type discipline: if a programmer encounters a TSM application when reading a well-typed program, they need only look up the TSM's type annotation to determine the type of that expression. They do not need to examine the expansion directly. 

\subsubsection{Hygiene}
Hygiene, a.k.a. a binding discipline, is achieved by maintaining the following properties:

\begin{itemize}
\item \textbf{Context Independence}: A TSM cannot make any assumptions about the typing context at the use site. This is achieved by giving access to the use site typing context only to spliced subexpressions (which the client of the TSM writes, rather than the TSM provider). 

An example of a ``bad'' TSM that assumes that a particular variable is available at the use site is the following:
\begin{lstlisting}[numbers=none]
syntax $bad1 at Rx {
	static fn(body : Body) => Success (Var 'SSTRxESTR')
}
\end{lstlisting}
The candidate expansion this TSM generates is well-typed only when there is a binding \li{x : Rx} at the use site. Therefore, it is deemed invalid.

In the example in Sec. \ref{sec:uetsms-usage}, the expansion used constructors associated with the \li{Rx} type, e.g. \li{Seq} and \li{Str}. This might appear to violate context independence. However, this is not the case because in VerseML, constructor labels are distinguished from variables. Syntactically, they must begin with a capital letter (as in Haskell). Different type definitions can use the same constructor label without conflict because the type the term is being checked against -- here \li{Rx}, due to the type ascription on \li{#\dolla#rx} -- determines which type of value is to be constructed.

\item \textbf{Context Invariance}: Spliced subexpressions have access to only those variables that were bound at the use site. The TSM cannot introduce new bindings into spliced subexpressions. For example, consider the following candidate expansion (written concretely as above):
\begin{lstlisting}[numbers=none]
fn(x : Rx) => spliced<0, 4>
\end{lstlisting}
The variable \li{x} would not be available to the indicated spliced subexpression (nor would it shadow any bindings of \li{x} at the use site).

This does limit the ability of library providers to define derived forms for abstractions that involve novel syntax for binding. For example, Haskell's derived forms for monadic commands involve binding the result of a command to a variable. In VerseML, programmers must use the built-in function form to pass data through variables. We will return to this example when we discuss parameterized TSMs in Chapter \ref{sec:tsms-parameterized}.
\end{itemize}

These properties suffice to ensure that programmers and tools can freely rename a variable without changing the meaning of the program. The only information that is necessary to perform such a \emph{rename refactoring} is the location of spliced subexpressions within all the literal forms in scope of the variable; the expansions need not otherwise be examined. It would be straightforward to develop a tool and/or editor plugin to indicate the locations of spliced subexpressions to the user, just as we do in this document (by coloring spliced subexpressions black). We discuss tool support as future work in Sec. \ref{sec:interaction-with-tools}.

\todo{does above paragraph need to expanded?}

\subsubsection{Final Expansion}
After checking that the candidate expansion is {valid}, the semantics replaces the references to spliced subexpressions with the subexpressions themselves, producing the final expansion. For example, the final expansion of the body of \li{example_rx_tsm} is:
\begin{lstlisting}[numbers=none]
Seq(Str(name), Seq(Str "SSTR: ESTR", ssn))
\end{lstlisting}
%Put another way, the  elaboration logic must be valid in any context. 


\section{TSMs For Defining TSMs}\label{sec:tsms-for-tsms}
\subsection{Quasiquotation}
TSMs can be used when defining parse functions. For example, rather than construct values of type \li{MarkedExp} explicitly, the prelude includes a TSM that provides quasiquotation syntax like that described in Sec. \ref{sec:syntax-examples-quasiquotation}:
\begin{lstlisting}[numbers=none]
syntax $qq at MarkedExp {
	static fn(body) => (* quasiquotation parser here *)
}
\end{lstlisting}
For example, the following TSM application:
\begin{lstlisting}[numbers=none]
let gx = $qq `SQTg(x)EQT`
\end{lstlisting}
is more concise than its expansion:
\begin{lstlisting}[numbers=none]
let gx = App(Var 'SSTRgESTR', Var 'SSTRxESTR')
\end{lstlisting}
Anti-quotation is simply splicing in another value of type \li{MarkedExp}, here indicated by prefix \li{%}:
\begin{lstlisting}[numbers=none]
let fgx = $qq `SQTf(%EQTgxSQT)EQT`
\end{lstlisting}
The expansion of this term is:
\begin{lstlisting}[numbers=none]
let fgx = App(Var 'SSTRfESTR', gx)
\end{lstlisting}

\subsection{Parser Generators}
\todo{grammars, compile function, TSM for grammar, example of IP address}

\section{Minimal Formalization}\label{sec:tsms-minimal-formalism}

\begin{figure}$\begin{array}{llllll}
\textbf{variables} & \textbf{type variables} & \textbf{TSM variables} & \textbf{bodies}\\
x & t & m & b\\~\end{array}$\\
$\begin{array}{l}
\textbf{types}\\
\tau ::= t ~\vert~ \parr{\tau}{\tau} ~\vert~ \forallt{t}{\tau} ~\vert~ \rect{t}{\tau} ~\vert~ \unitt\\
~\\
\textbf{marked types}\\
\mtau ::= t ~\vert~ \parr{\mtau}{\mtau} ~\vert~ \forallt{t}{\mtau} ~\vert~ \rect{t}{\mtau} ~\vert~ \unitt ~\vert~ \mtspliced{\tau}\\
~\\
\textbf{TSM expressions}\\
\tsme ::= \tsmv ~\vert~ \utsmdef{\tau}{\ue}
\\~\\
\textbf{unexpanded expressions}\\
\ue ::= {x} ~\vert~ \lam{x}{\tau}{\ue} ~\vert~ \ue(\ue) ~\vert~ \Lam{t}{\ue} ~\vert~ \App{\ue}{\tau} ~\vert~ \fold{t}{\tau}{\ue} ~\vert~ \unfold{\ue} ~\vert~ \triv ~\vert~ \uletsyntax{\tsmv}{\tsme}{\ue} ~\vert~ \utsmapp{\eta}{b}
\\~\\
\textbf{marked expressions}\\
\me ::= x ~\vert~ \lam{x}{\mtau}{\me} ~\vert~ \app{\me}{\me} ~\vert~ \Lam{t}{\me} ~|~ \App{\me}{\mtau} ~\vert~ \fold{t}{\mtau}{\me} ~\vert~ \unfold{\me} ~\vert~ \triv ~\vert~ \mspliced{e}
\\~\\
\textbf{expanded expressions}\\
e ::= x ~\vert~ \lam{x}{\tau}{e} ~\vert~ \app{e}{e} ~\vert~ \Lam{t}{e} ~\vert~ \App{e}{\tau} ~\vert~ \fold{t}{\tau}{e} ~\vert~ \unfold{e} ~\vert~ \triv\end{array}\\\vspace{8px}$
~\\
$\begin{array}{ll}
\textbf{type formation contexts} & \textbf{typing contexts}\\
\Delta ::= \emptyset ~\vert~ \Delta, t & \Gamma ::= \emptyset ~\vert~ \Gamma, x : \tau
\end{array}$

\todo{add sum and product types}\\
\todo{add nat}
\caption{Syntax of $\LTSM$}
\label{fig:lambda-tsm-syntax}
\end{figure}


To give a formal account of unparameterized expression TSMs, we will now introduce a typed lambda calculus, $\LTSM$. The syntax of $\LTSM$ is shown in Figure \ref{fig:lambda-tsm-syntax}.

\subsection{Types and Expanded Expressions}
\begin{figure}
\todo{write this down}
\caption{Static semantics of expanded expressions in $\LTSM$}
\label{fig:expanded-statics}
\end{figure}
\begin{figure}
\todo{write this down}
\caption{Dynamic semantics of $\LTSM$}
\label{fig:expanded-dynamics}
\end{figure}
\emph{Types}, $\tau$, and \emph{expanded expressions}, $e$, form a standard typed lambda calculus supporting partial functions, quantification over types, recursive types and for simplicity, a single base type, $\mathsf{1}$. The reader can consult any standard text covering typed programming languages for the necessary background (e.g. \emph{TAPL} \cite{tapl} or \emph{PFPL} \cite{pfpl}). We will reproduce a more detailed account of the semantics of the language in the dissertation, but for our present purposes, it suffices to recall the relevant judgement forms. The static  semantics of expanded expressions can be specified by judgements of the following form:

$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\Delta \vdash \tau~\mathtt{type} & \text{$\tau$ is a valid type under type formation context $\Delta$}\\
\Delta \vdash \Gamma~\mathtt{ctx} & \text{$\Gamma$ is a valid typing context under $\Delta$}\\
\Delta~\Gamma \vdash e : \tau & \text{$e$ has type $\tau$ under $\Delta$ and $\Gamma$}
\end{array}$

\noindent
The dynamic semantics can be specified by judgements of the following form:

$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
e \mapsto e' & \text{$e$ transitions to $e'$}\\
e~\mathtt{val} & \text{$e$ is a value}
\end{array}$
\\\noindent
We will write $e \mapsto^* e'$ for the reflexive, transitive closure of the transition relation and $e \Downarrow e'$ iff $e \mapsto^* e'$ and $e'~\mathtt{val}$.

\subsection{Macro Expansion and Validation}
\begin{figure}
\todo{write this down}
\caption{Typed Expansion}
\label{fig:u-typed-expansion}
\end{figure}
\begin{figure}
\begin{lstlisting}
(* we leave var and tvar abstract in the metatheory; see text *)
type var
type tvar
type Nat = Z | S of Nat
type Ty = TVar of tvar | Parr of Ty * Ty | Forall of tvar * Ty 
	| Rec of tvar * Ty | Unit | Prod of Ty * Ty | Sum of Ty * Ty
	| SplicedTy of Nat * Nat
type Exp = Var of var | Abs of var * Ty * Exp | App of Exp * Exp
	| TyAbs of tvar * Exp | TyApp of Exp * Ty
	| Fold of tvar * Ty * Exp | Unfold of Exp
	| Triv | Pair of Exp * Exp | Fst of Exp | Snd of Exp
	| InL of Ty * Exp | InR of Ty * Exp | Case of Exp * var*Exp * var*Exp
	| SplicedExp of Nat * Nat
\end{lstlisting}
\todo{use math font}
\todo{reference tihs figure}\\
\todo{ack. that there are other possible encodings that might be useful in practice, e.g. ABTs}
\caption[Expansion Encodings]{Definition of types for expansion encodings in $\LTSM$. For clarity, we use OCaml-style type definitions with explicit constructor labels here and in the remainder of this section. The mapping from these definitions to the unlabeled recursive sum types found in $\LTSM$ is straightforward (e.g. \texttt{Nat} corresponds to $\rect{t}{\sumt{\unitt}{t}}$) and thus omitted for concision.}
\label{fig:visible-compiler}
\end{figure}
\begin{figure}
\todo{write this down}
\caption{Expansion Decoding}
\label{fig:u-expansion-decoding}
\end{figure}
\begin{figure}
\todo{write this down}
\caption{Expansion Validation}
\label{fig:u-expansion-validation}
\end{figure}
Programs ultimately evaluate as expanded expressions, but programmers write programs as \emph{unexpanded expressions}, $\ue$. Unexpanded expressions are typechecked and expanded simultaneously according to the rules defining the \emph{typed expansion judgement}:

$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\Delta~\Gamma \vdash \ue \leadsto e : \tau & \text{$\ue$ expands to $e$ at type $\tau$ under $\Delta$ and $\Gamma$}
\end{array}$

Every form in the syntax of $e$ has a corresponding form in the syntax of $\ue$ (cf. Figure \ref{fig:lambda-tsm-syntax}). For each rule in the static semantics of $e$, there is a corresponding typed expansion rule where the unexpanded and expanded forms correspond. For example, the rules for variables, functions and function application are shown below (the remaining such rules are analagous, but we omit them here for concision):
\begin{mathpar}
\inferrule[T-U-var]{ }{\Delta~\Gamma, x : \tau \vdash x \leadsto x : \tau}

\inferrule[T-U-abs]{
	\Delta \vdash \tau_1~\mathtt{type}\\
	\Delta~\Gamma, x:\tau \vdash \ue \leadsto e : \tau'
}{
	\Delta~\Gamma \vdash \lambda x{:}\tau.\ue \leadsto \lambda x{:}\tau.e : \tau \rightharpoonup \tau'
}

\inferrule[T-U-ap]{
	\Delta~\Gamma \vdash \ue_1 \leadsto e_1 : \tau \rightharpoonup \tau' \\
	\Delta~\Gamma \vdash \ue_2 \leadsto e_2 : \tau
}{
	\Delta~\Gamma \vdash \ue_1(\ue_2) \leadsto e_1(e_2) : \tau'
}
\end{mathpar}
There are two forms in the syntax of $\ue$ that have no corresponding form in the syntax of $e$. The first allows the programmer to bind a \emph{TSM variable}, $m$, to a \emph{TSM expression}, $\eta$. TSM expressions are either TSM variables or \emph{TSM definitions}. Substitution for TSM variables is performed statically, so we only need a rule for the case where the TSM variable is being bound to a TSM definition:
\begin{mathpar}
\inferrule[T-U-TSM-let]{
	\Delta \vdash \mathsf{syntax}~@~\tau~\{\ue_\text{parse}\}~\mathtt{tsm}\\
	\Delta~\Gamma \vdash [\mathsf{syntax}~@~\tau~\{\ue_\text{parse}\}/m]\ue \leadsto e : \tau'
}{
	\Delta~\Gamma \vdash \mathsf{let}~\mathsf{syntax}~m=\mathsf{syntax}~@~\tau~\{\ue_\text{parse}\}~\mathsf{in}~\ue \leadsto e : \tau'
}
\end{mathpar}
The first premise checks that the TSM definition is valid. It is defined by the following rule:
\begin{mathpar}
\inferrule[TSM-OK]{
	\Delta \vdash \tau~\mathtt{type}\\
	\emptyset~\emptyset \vdash \ue_\text{parse} \leadsto e_\text{parse} : \mathsf{Body} \rightharpoonup \mathsf{Exp}
}{
	\Delta \vdash \mathsf{syntax}~@~\tau~\{\ue_\text{parse}\}~\mathtt{tsm}
}
\end{mathpar}
The first premise of (TSM-OK) checks that the type is valid. The second premise typechecks and expands the parse function, which must be closed. We discuss the abbreviated types $\mathsf{Body}$ and $\mathsf{Exp}$ below.

The second form in the syntax of $\ue$ that has no corresponding form in the syntax of $e$ is the form for TSM application to a delimited body, $\eta\,\texttt{/}b\texttt{/}$. Again because substitution for TSM variables is performed statically, we only need a rule for the case where $\eta$ is a TSM definition:
\begin{mathpar}
\inferrule[T-U-TSM-ap]{
	\Delta \vdash \tau~\mathtt{type}\\
	\emptyset~\emptyset \vdash \ue_\text{parse} \leadsto e_\text{parse} : \mathsf{Body} \rightharpoonup \mathsf{Exp}\\\\
	b \downarrow e_\text{body} : \mathsf{Body}\\
	e_\text{parse}(e_\text{body}) \Downarrow e_\text{exp}\\
	e_\text{exp} : \mathsf{Exp} \uparrow \dot{e}_\text{exp}\\\\
	\Delta~\Gamma; \emptyset~\emptyset \vdash \dot{e}_\text{exp} \leadsto e : \tau
}{
	\Delta~\Gamma \vdash \mathsf{syntax}~@~\tau~\{\ue_\text{parse}\}~\texttt{/}b\texttt{/} \leadsto e : \tau
}
\end{mathpar}
The premises can be understood as follows, in order:
\begin{enumerate}
\item The first premise checks that the type specified by the TSM is valid.
\item The second premise typechecks and expands the parse function.
\item The third premise encodes the body, $b$, as a term, $e_\text{body}$ of type $\mathsf{Body}$ (we will give more details on how bodies are encoded in the dissertation, but omit the definition of $\mathsf{Body}$ here for concision).
\item The fourth premise applies the expanded parse function to the encoding of the body to produce an encoding of the expansion, $e_\text{exp}$, of  type $\mathsf{Exp}$. 
\item Values of type $\mathsf{Exp}$ map onto \emph{marked expressions}, $\dot{e}$. Per Figure \ref{fig:lambda-tsm-syntax}, marked expressions can contain variables, type variables and marked types, $\dot{\tau}$, so there is also a mapping from values of types abbreviated $\mathsf{Var}$, $\mathsf{TVar}$ and $\mathsf{Type}$ onto variables, type variables, and {marked types}, respectively. We also omit the full definitions of these types for concision (cf. the SML/NJ Visible Compiler library \cite{SML/VisibleCompiler} for an example of such an encoding of the abstract syntax of a language). These mappings are specified by the \emph{expansion decoding judgements}:

$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
e : \mathsf{Var} \uparrow x & \text{$e$ decodes to variable $x$.}\\
e : \mathsf{TVar} \uparrow t & \text{$e$ decodes to type variable $t$.}\\
e : \mathsf{Type} \uparrow \dot{\tau} & \text{$e$ decodes to marked type $\dot{\tau}$.}\\
e : \mathsf{Exp} \uparrow \dot{e} & \text{$e$ decodes to marked expression $\dot{e}$.}\\
\end{array}$

The fifth premise decodes $e_\text{exp}$ to produce the \emph{marked expansion}, $\dot{e}_\text{exp}$. 
\item The final premise valides the expansion by checking the marked expansion against the type specified by the TSM, and generates the final expansion, $e$, according to the rules defining the \emph{expansion validation judgements}:

$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\Delta_\text{out}; \Delta \vdash \dot{\tau} \leadsto \tau~\mathtt{type} & \text{Marked type $\dot{\tau}$ expands to $\tau$ under outer context $\Delta_\text{out}$}\\
& \text{and current context $\Delta$.}\\
\Delta_\text{out}~\Gamma_\text{out}; \Delta~\Gamma \vdash \dot{e} \leadsto e : \tau & \text{Marked expression $\dot{e}$ expands to $e$ at type $\tau$ under outer}\\
& \text{contexts $\Delta_\text{out}$ and $\Gamma_\text{out}$ and current contexts $\Delta$ and $\Gamma$.}
\end{array}$

Each form in the syntax of expanded expressions has a corresponding form in the syntax of marked expressions (cf. Figure \ref{fig:lambda-tsm-syntax}). For each rule in the static semantics of $e$, there is a corresponding expansion validation rule where the marked and expanded forms correspond. Only the current contexts are examined or extended by these rules. For example, the expansion validation rules for variables, functions and function application are shown below (the remaining such rules are analagous, but we omit them for concision):
\begin{mathpar}
\inferrule[T-M-var]{ }{\Delta_\text{out}~\Gamma_\text{out}; \Delta~\Gamma, x : \tau \vdash x \leadsto x : \tau}

\inferrule[T-M-abs]{
	\Delta_\text{out}; \Delta \vdash \dot{\tau} \leadsto \tau ~\mathtt{type}\\
	\Delta_\text{out}~\Gamma_\text{out}; \Delta~\Gamma, x : \tau \vdash \dot{e} \leadsto e : \tau'
}{
	\Delta_\text{out}~\Gamma_\text{out}; \Delta~\Gamma \vdash \lambda x{:}\dot{\tau}.\dot{e} \leadsto \lambda x{:}\tau.e : \tau \rightharpoonup \tau'
}

\inferrule[T-M-app]{
	\Delta_\text{out}~\Gamma_\text{out}; \Delta~\Gamma \vdash \dot{e}_1 \leadsto e_1 : \tau \rightharpoonup \tau'\\
	\Delta_\text{out}~\Gamma_\text{out}; \Delta~\Gamma \vdash \dot{e}_2 \leadsto e_2 : \tau
}{
	\Delta_\text{out}~\Gamma_\text{out}; \Delta~\Gamma \vdash \dot{e}_1(\dot{e}_2) \leadsto e_1(e_2) : \tau'
}
\end{mathpar}

The purpose of the outer contexts is to ``remember'' the context that the macro application appeared in so that spliced subexpressions extracted from the body, which are marked with the form $\mathsf{spliced}(\ue)$, can be checked appropriately:
\begin{mathpar}
\inferrule[T-M-spliced]{
	\Delta_\text{out}~\Gamma_\text{out} \vdash \ue \leadsto e : \tau
}{
	\Delta_\text{out}~\Gamma_\text{out}; \Delta~\Gamma \vdash \mathsf{spliced}(\ue) \leadsto e : \tau
}
\end{mathpar}

The current contexts are initially empty when checking the marked expansion generated by the parse function, so we achieve hygiene: the expansion cannot make any assumptions about the variables available in the outer context. 
%The translation of the elaboration becomes the translation in the conclusion of the rule.
\end{enumerate}

\subsection{Metatheory}
\subsection{Static Language}\label{sec:static-subset}
\section{Additional Conveniences}
\section{Limitations}
\chapter{Pattern TSMs}\label{sec:pattern-tsms}
TSMs as we have described them so far decrease the syntactic cost of introducing a value at a specified type. In full-scale functional languages like ML, one typically deconstructs a value using \emph{nested pattern matching}. For example, let us return to the definition of the datatype \lstinline{Rx} shown at the beginning of Sec. \ref{sec:examples}. We can pattern match over a value, \lstinline{r}, of type \lstinline{Rx} using VerseML's \lstinline{match} construct like this:
\begin{lstlisting}[numbers=none]
match r with 
    Seq(Str(name), Seq(Str ": ", ssn)) => display name ssn
  |  _ => raise Invalid
\end{lstlisting}
In a functional language with primitive support for regular expression pattern syntax, we would expect to be able to write this example more concisely using the splicing forms discussed in Sec. \ref{sec:tsms-by-example}:
\begin{lstlisting}[numbers=none]
match r with 
    /SURL@EURLnameSURL: %EURLssn/ => display name ssn
  | _ => raise Invalid
\end{lstlisting}

Patterns are not expressions, so we cannot simply use a TSM defined at type \lstinline{Rx} in a pattern. To address this, we must extend our language with support for typed pattern syntax macros (TPSMs). TPSMs are entirely analagous to TSMs, differing primarily in that the expansions they generate are patterns, rather than expressions. Assuming the abstract syntax of patterns is encoded by the type \lstinline{Pat} (analagous to \lstinline{Exp}), we can define a TPSM at type \lstinline{Rx} as follows:
\begin{lstlisting}[numbers=none]
pattern syntax rx at Rx {
	static fn (body : Body) : Pat => 
	  (* regex pattern parser here *)
}
\end{lstlisting}

Using this TPSM, we can rewrite our example as follows:
\begin{lstlisting}[numbers=none]
match r with 
    rx /SURL@EURLnameSURL: %EURLssn/ => display name ssn
  | _ => raise Invalid
\end{lstlisting}
To ensure that the client of the TPSM need not ``guess at'' what variables are bound by the pattern, variables (e.g. \lstinline{name} and \lstinline{ssn} here) can only appear in spliced subpatterns (just as variables bound at the use site can only appear in spliced subexpressions when using TSMs). We leave a formal account of TPSMs (in a reduced calculus that features simple pattern matching) as work that remains to be completed (see Sec. \ref{sec:syntax-timeline}).

ML does not presently support pattern matching over values of an abstract data type. However, there have been proposals for adding support for pattern matching over abstract data types defined by modules having a ``datatype-like'' shape, e.g. those that define a case analysis function like the one specified by \lstinline{RX}, shown in Sec. \ref{sec:examples}. We leave further discussion of such a facility and of parameterized TPSMs also as remaining work (see Sec. \ref{sec:syntax-timeline}). 

\chapter{Parameterized TSMs}\label{sec:tsms-parameterized}


% !TEX root = omar-thesis.tex
\chapter{Unparameterized Expression TSMs}\label{chap:tsms}
We now introduce a new primitive -- the \textbf{typed syntax macro} (TSM) -- that combines much of the syntactic flexibility of syntax extensions with the reasoning guarantees of typed macros. This chapter focuses on the simplest case: TSMs that generate expressions of a single specified type (\emph{unparameterized expression TSMs}). We will consider pattern matching in Chapter \ref{sec:pattern-tsms} and parameterized families of types in Chapter \ref{sec:tsms-parameterized}.

We begin in Sec. \ref{sec:tsms-by-example} by describing expression TSMs in VerseML by example.  In particular, we will show a TSM for introducing values of the type \li{Rx} defined in Figure \ref{fig:datatype-rx}. We then formally specify unparameterized expression TSMs with a lambda calculus, $\miniVerseU$, in Sec. \ref{sec:tsms-minimal-formalism}. 


%Like the term-rewriting macros just described, TSMs can be parameterized by modules, so they can be used to define syntax valid at any abstract type defined by a module satisfying a specified signature. As we will discuss in the remainder of this section, this addresses all of the problems brought up above, at moderate syntactic cost.

\section{Expression TSMs By Example}\label{sec:tsms-by-example}
%A typed syntax macro is invoked by applying it to a \emph{delimited form}, which can contain  arbitrary syntax in its \emph{body}.  

\subsection{Usage}\label{sec:uetsms-usage}
Consider the following concrete VerseML expression:
\begin{lstlisting}[numbers=none,mathescape=|]
$rx /SURLA|T|G|CEURL/
\end{lstlisting}
We apply a {TSM}, identified as \lstinline{#\dolla#rx}, 
to a \emph{literal form}, \lstinline{/SURLA|T|G|CEURL/}. Literal forms are left unparsed when concrete expressions are first parsed by a VerseML compiler. A number of literal forms, shown in Figure \ref{fig:literal-forms},  are available in VerseML's concrete syntax. Though certain TSMs may by convention call for the use of particular literal forms, any literal form can be used with any TSM, e.g. we could have written \lstinline{#\dolla#rx `SURLA|T|G|CEURL`} above (this would actually be convenient if we wanted to write a regex containing forward slashes but not backticks). Because the set of literal forms is fixed by VerseML, TSMs cannot introduce syntactic conflicts by construction.

During the typechecking process, the TSM parses the \emph{body} of the provided literal form, i.e. the characters in blue, to generate a \emph{candidate expansion}. The language then \emph{validates} the candidate expansion, according to criteria that we will establish in Sec. \ref{sec:uetsms-validation}. If validation succeeds, the language generates the \emph{final expansion} (or more concisely, simply the \emph{expansion}) of the expression. The expansion of the expression above, written concretely, is:
\begin{lstlisting}[numbers=none]
Or(Str "SSTRAESTR", Or(Str "SSTRTESTR", Or(Str "SSTRGESTR", Str "SSTRCESTR")))
\end{lstlisting}
The constructors in the expansion above are those of the type \li{Rx} that was defined in Figure \ref{fig:datatype-rx}.

 %The form does not directly determine the expansion. 

\begin{figure}
\begin{lstlisting}
'SURLbody cannot contain an apostropheEURL'
`SURLbody cannot contain a backtickEURL`
[SURLbody cannot contain unmatched square bracketsEURL]
{SURLbody cannot contain an unmatched curly braceEURL}
/SURLbody cannot contain a forward slashEURL/
\SURLbody cannot contain a backslashEURL\
SURL42EURL (* numeric forms *)
SURL42pxEURL (* numeric forms with suffixes *)
\end{lstlisting}
%SURL<tag>body includes enclosing tags</tag>EURL
\caption[Available Literal Forms]{Literal forms available for use with TSMs (and TSLs, cf. Chapter \ref{chap:tsls}) in VerseML's concrete syntax. The characters in blue are the literal bodies. In this figure, each line describes how the body is constrained by the form shown on that line. The Wyvern language specifies additional forms, including whitespace-delimited forms \cite{TSLs} and multipart forms \cite{sac15}, but for simplicity we leave these out of VerseML.}
\label{fig:literal-forms}
\end{figure}
\subsection{Definition}\label{sec:uetsms-definition}
%The original expression, above, is statically rewritten to this expression.
The definition of the TSM \lstinline{#\dolla#rx} shown in use above has the following form:
\begin{lstlisting}[numbers=none,mathescape=|]
syntax $rx at Rx {
  static fn(body : Body) : ParseResultExp => (* regex parser here *)
}
\end{lstlisting}
This {TSM definition} first identifies the TSM as \lstinline{#\dolla#rx}. 
VerseML requires that all TSM variable identifiers begin with a dollar sign (to clearly distinguish TSMs from functions). A similar convention is also enforced by the Rust macro system \cite{Rust/Macros}.

The TSM definition then specifies a \emph{type annotation}, \lstinline{at Rx}, and a \emph{parse function}, within curly braces. 
The {parse function} is a \emph{static function} that parses the literal body to generate an encoding of the candidate expansion, or an error if one cannot be generated (e.g. when the body is ill-formed according to the syntactic specification that the TSM implements).  Static functions are functions that will be evaluated statically (and they cannot refer to surrounding variable bindings). The parse function has type \li{Body -> ParseResult}. These types are defined in the VerseML \emph{prelude}, which is a set of definitions available ambiently. The input type, \lstinline{Body}, gives the parse function access to the {body} of the provided literal form, which can be represented as a string:
\begin{lstlisting}[numbers=none]
type Body = string
\end{lstlisting} 

The output type, \li{ParseResultExp}, is a labeled sum type that distinguishes between successful parses and parse errors:
\begin{lstlisting}[numbers=none]
type ParseResultExp = Success of CEExp 
                    | ParseError of {msg : string, loc : IndexRange}
\end{lstlisting}

Successful parses, constructed by \li{Success}, generate candidate expansions, which are encoded as values of type \lstinline{CEExp}, shown in Figure \ref{fig:candidate-exp-verseml}. 
\begin{figure}
\begin{lstlisting}[numbers=none]
type CETyp = TyVar of var_t 
                   | Arrow of CETyp * CETyp 
                   | ... 
                   | Spliced of IndexRange

type CEExp = Var of var_t 
                   | Fn of var_t * CETyp * CEExp
                   | App of CEExp * CEExp
                   | ... 
                   | Spliced of IndexRange
\end{lstlisting}
\caption[Abbreviated definitions of \li{CETyp} and \li{CEExp} in VerseML.]{Abbreviated definitions of \li{CETyp} and \li{CEExp} in VerseML. We assume some suitable type \li{var_t} exists, not shown.}
\label{fig:candidate-exp-verseml}
\end{figure}
The elided constructors in Figure \ref{fig:candidate-exp-verseml} encode the abstract syntax of VerseML expressions and types (as in the SML visible compiler \cite{SML/VisibleCompiler}).
% We will show a complete encoding when we describe our reduced formal system $\miniVerseU$ in Sec. \ref{sec:tsms-minimal-formalism}. 
We discuss the constructors labeled \li{Spliced} in Sec. \ref{sec:splicing-and-hygiene}. To decrease the syntactic cost of working with the types defined in Figure \ref{fig:candidate-exp-verseml}, the prelude implements \emph{quasiquotation syntax} using TSMs. We will discuss these TSMs in more detail in Sec. \ref{sec:tsms-for-tsms}. The definitions in Figure \ref{fig:candidate-exp-verseml} are recursive labeled sum types for simplicity, but alternative encodings of abstract syntax, e.g. based on abstract binding trees \cite{pfpl}, could also have been chosen with only minor modification to the semantics. % It is extended with one additional form used to handled spliced subexpressions, 

If the parse function determines that a candidate expansion cannot be generated, i.e. there is a parse error in the literal body, it returns a value constructed by \li{ParseError}. It must provide an error message and indicate the location of the error within the body of the literal form as a value of type \li{IndexRange}:
\begin{lstlisting}[numbers=none]
type IndexRange = {startIndex : nat, endIndex : nat} (* inclusive *)
\end{lstlisting}
The error message and error location can be used by VerseML compilers when reporting errors to the programmer.

%Notice that the types just described are those that one would expect to find in a typical parser.

%One would find types analagous to those just described in any parser, so for concision, we elide the details of \li{#\dolla#rx}'s parse function.
%The parse function must treat the TSM parameters parametrically, i.e. it does not have access to any values in the supplied module parameter. Only the expansion the parse function generates can refer to module parameters. 
%For example, the following definition is ill-sorted:
%\begin{lstlisting}[numbers=none]
%syntax pattern_bad[Q : PATTERN] at Q.t {
%  static fn (body : Body) : Exp => 
%    if Q.flag then (* ... *) else (* ... *)
%}
%\end{lstlisting}%So the parse function parses the body of the delimited form to generate an encoding of the elaboration.

\subsection{Splicing}\label{sec:splicing-and-hygiene}
To support spliced subexpressions, like we described in Sec. \ref{sec:syntax-examples-regexps}, the parse function must be able to parse subexpressions out of the supplied literal body. For example, consider the code snippet from Figure \ref{fig:derived-spliced-subexpressions}, rewritten using the \li{#\dolla#rx} TSM:
\begin{lstlisting}[numbers=none]
val ssn = $rx /SURL\d\d\d-\d\d-\d\d\d\dEURL/
fun example_rx_tsm(name: string) => $rx /SURL@EURLnameSURL: %EURLssn/
\end{lstlisting}
The subexpressions \lstinline{name} and \lstinline{ssn} on the second line appear directly in the body of the literal form, so we call them \emph{spliced subexpressions}. When the parse function determines that a subsequence of the body should be treated as a spliced subexpression (here, by recognizing the characters \lstinline{@} or \lstinline{%} followed by a variable or parenthesized expression), 
it can refer to it within the candidate expansion it generates using the \li{Spliced} constructor of the \li{CEExp} type shown in Figure \ref{fig:candidate-exp-verseml}. Spliced subexpressions are referred to indirectly by their position within the literal body (i.e. with a value of type \li{IndexRange}, defined above) to prevent TSMs from forging a spliced subexpression (i.e. claiming that an expression is a spliced subexpression, even though it does not appear in the body of the literal form). Expressions can contain type expressions, so one can also mark spliced type expressions in an analagous manner. %In particular, the parse function must provide the index range of spliced subexpressions to the \li{Spliced} constructor of the type \li{MarkedExp}. %Only subexpressions that actually appear in the body of the literal form can be marked as spliced subexpressions.

The candidate expansion generated by \li{#\dolla#rx} for the body of \lstinline{example_rx_tsm}, if written in a hypothetical concrete syntax for candidate expansions where spliced subexpressions are written \li{spliced<startIdx, endIndex>}, is:
\begin{lstlisting}[numbers=none]
Seq(Str(spliced<1, 4>), Seq(Str "SSTR: ESTR", spliced<8, 10>))
\end{lstlisting}
Here, \li{spliced<1, 4>} refers to the subexpression \li{name} by position and \li{spliced<8, 10>} refers to the subexpression \li{ssn} by position. 

%For example, had the  would not be a valid expansion, because the  that are not inside spliced subexpressions:
%\begin{lstlisting}[numbers=none]
%Q.Seq(Q.Str(name), Q.Seq(Q.Str ": ", ssn))
%\end{lstlisting}

\subsection{Typing}\label{sec:uetsms-validation}
The language \emph{validates} candidate expansions. The first check involves checking the candidate expansion against the type annotation specified by the TSM, i.e. the type \li{Rx} in the example above. This maintains a type discipline: if a programmer encounters a TSM being applied when reading a well-typed program, they need only look up the TSM's type annotation to determine the type of that expression. They do not need to examine the expansion directly. 

The spliced subexpressions that the candidate expansion refers to (by their position within the literal body, cf. above) are recursively parsed, typed and expanded during this process.

\subsection{Hygiene}
To maintain a useful binding discipline, the validation process checks two additional properties: \textbf{context independent expansion} and \textbf{expansion independent splicing}. These are collectively referred to as the \emph{hygiene properties}.

\paragraph{Context Independent Expansion} Programmers expect to be able to choose variable identifiers freely, i.e. without ``hidden constraints'' imposed by the TSMs they are using. For this reason, context-dependent candidate expansions, i.e. those with free variables, are deemed invalid (even at application sites where those variables happen to be bound). An example of a ``bad'' TSM that generates context-dependent expansions is shown below:
\begin{lstlisting}[numbers=none]
syntax $bad1 at Rx {
	static fn(body : Body) : ParseResultExp => Success (Var 'SSTRxESTR')
}
\end{lstlisting}
The candidate expansion this TSM generates would be well-typed only when there is a binding \li{x : Rx} in the application site typing context, so it is deemed invalid (even in such a context). 

Application site bindings are, however, available when recursively typing and expanding the spliced subexpressions referred to in the candidate expansion because spliced subexpressions are authored by the TSM client and appear at the application site. We saw examples of spliced subexpressions that referred to variables bound at the application site in Sec. \ref{sec:splicing-and-hygiene}.% The TSM provider can only refer to them opaquely.

In the examples in Sec. \ref{sec:uetsms-usage} and Sec. \ref{sec:splicing-and-hygiene}, the expansion used constructors associated with the \li{Rx} type, e.g. \li{Seq} and \li{Str}. This might appear to violate context independence. However, this is not the case because in VerseML, constructor labels are not variables. Syntactically, they must begin with a capital letter (as in Haskell). Different labeled sum types can use common constructor labels without conflict because the type the term is being checked against -- e.g. \li{Rx}, due to the type ascription on \li{#\dolla#rx} -- determines which type of value will be constructed.% Indeed, we used the label \li{Spliced} for two different recursive labeled sum types in Figure \ref{fig:candidate-exp-verseml}.

\paragraph{Expansion Independent Splicing} Spliced subexpressions have access to only those variables that were bound at the application site, i.e. a TSM cannot introduce new bindings into spliced subexpressions. For example, consider the following hypothetical candidate expansion (written concretely as above):
\begin{lstlisting}[numbers=none]
fn(x : Rx) => spliced<0, 4>
\end{lstlisting}
The variable \li{x} would not be available when typing the indicated spliced subexpression, nor would it shadow any bindings of \li{x} at the application site.

The benefit of maintaining this property is that the TSM client can determine which bindings are available in a spliced subexpression without examining the expansion it appears within. There are no ``hidden variables''. The trade-off is that this prevents library providers from defining  alternative binding idioms. For example, Haskell's derived form for monadic commands (i.e. \li{do}-notation) supports binding the result of executing a command to a variable that is then available in the subsequent commands in a command sequence. We will show an alternative formulation of Haskell's syntax for monadic commands that uses VerseML's anonymous function syntax to bind variables in Sec. \ref{sec:application-monadic-commands}. We will discuss mechanisms that might allow us to relax this restriction while retaining client control over variable naming as future work in Sec. \ref{sec:controlled-binding}.

%These properties suffice to ensure that programmers and tools can freely rename a variable without changing the meaning of the program. The only information that is necessary to perform such a \emph{rename refactoring} is the locations of spliced subexpressions within all the literal forms for which the variable being renamed is in scope; the expansions need not otherwise be examined. It would be straightforward to develop a tool and/or editor plugin to indicate the locations of spliced subexpressions to the user, like we do in this document (by coloring spliced subexpressions black). We discuss tool support as future work in Sec. \ref{sec:interaction-with-tools}.

\subsubsection{Final Expansion}
After checking that the candidate expansion is {valid}, the semantics generates the \emph{final expansion} by replacing the references to spliced subexpressions with their final expansions. For example, the final expansion of the body of \li{example_rx_tsm} is:
\begin{lstlisting}[numbers=none]
Seq(Str(name), Seq(Str "SSTR: ESTR", ssn))
\end{lstlisting}
%Put another way, the  elaboration logic must be valid in any context. 



\section{$\miniVerseU$}\label{sec:tsms-minimal-formalism}

% \begin{figure}[p!]
% $\begin{array}{lllllll}
% \textbf{variables} & \textbf{type variables} & \textbf{labels} & \textbf{label sets} & \textbf{TSM variables} & \textbf{literal bodies} & \textbf{nats}\\
% x & t & \ell & \labelset & \tsmv & b & n\\~\end{array}$\\
% $\begin{array}{ll}
% \textbf{type formation contexts} & \textbf{typing contexts}\\
% \Delta ::= \emptyset ~\vert~ \Delta, t & \Gamma ::= \emptyset ~\vert~ \Gamma, x : \tau\\
% ~
% \end{array}$\\
% ~\\
% $\begin{array}{lcl}
% \gheading{types}\\
% \tau & ::= & t ~\vert~ \parr{\tau}{\tau} ~\vert~ \forallt{t}{\tau} ~\vert~ \rect{t}{\tau} ~\vert~  \prodt{\mapschema{\tau}{i}{\labelset}} ~\vert~ \sumt{\mapschema{\tau}{i}{\labelset}}\\
% ~\\
% \gheading{expanded expressions}\\
% e & ::= & x ~\vert~ \lam{x}{\tau}{e} ~\vert~ \app{e}{e} ~\vert~ \Lam{t}{e} ~\vert~ \App{e}{\tau} ~\vert~ \fold{t}{\tau}{e} ~\vert~ \unfold{e} ~\vert~ \tpl{\mapschema{e}{i}{\labelset}} ~\vert~ \prj{e}{\ell} \\
% & \vert & \inj{\ell}{e} ~\vert~ \caseof{e}{\mapschemab{x}{e}{i}{\labelset}}\\
% ~\\
% \gheading{TSM expressions}\\
% \tsme & ::= & \tsmv ~\vert~ \utsmdef{\tau}{\ue}\\
% ~\\
% \gheading{unexpanded expressions}\\
% \ue & ::= & {x} ~\vert~ \lam{x}{\tau}{\ue} ~\vert~ \ue(\ue) ~\vert~ \Lam{t}{\ue} ~\vert~ \App{\ue}{\tau} ~\vert~ \fold{t}{\tau}{\ue} ~\vert~ \unfold{\ue} ~\vert~ \tpl{\mapschema{\ue}{i}{\labelset}} ~\vert~ \prj{\ue}{\ell} \\
% & \vert & \inj{\ell}{\ue} ~\vert~ \caseof{\ue}{\mapschemab{x}{\ue}{i}{\labelset}}\\
% & \vert & \uletsyntax{\tsmv}{\tsme}{\ue} ~\vert~ \utsmapp{\eta}{b}\\
% ~\\
% \gheading{candidate expansion types}\\
% \mtau & ::= & t ~\vert~ \parr{\mtau}{\mtau} ~\vert~ \forallt{t}{\mtau} ~\vert~ \rect{t}{\mtau} ~\vert~ \prodt{\mapschema{\tau}{i}{\labelset}} ~\vert~ \sumt{\mapschema{\mtau}{i}{\labelset}} \\
% & \vert & \mtspliced{\tau}\\
% ~\\
% \gheading{candidate expansion expressions}\\
% \me & ::= & x ~\vert~ \lam{x}{\mtau}{\me} ~\vert~ \app{\me}{\me} ~\vert~ \Lam{t}{\me} ~|~ \App{\me}{\mtau} ~\vert~ \fold{t}{\mtau}{\me} ~\vert~ \unfold{\me} ~\vert~ \tpl{\mapschema{\me}{i}{\labelset}} ~\vert~ \prj{\me}{\ell} \\
% & \vert & \inj{\ell}{\me} ~\vert~ \caseof{\me}{\mapschemab{x}{\me}{i}{\labelset}}\\
% & \vert & \mspliced{e}
% % \\~
% \end{array}$
% \todo{finish breaking this up into syntax tables}
% \caption[Syntax of $\miniVerseU$]{Syntax of $\miniVerseU$. The forms $\mapschema{V}{i}{\labelset}$ and $\mapschemab{x}{V}{i}{\labelset}$ where $V$ is a metavariable indicate finite mappings from each label $i \in \labelset$ to a term, $V_i$, or binder, $x_i.V_i$, respectively.}
% \label{fig:lambda-tsm-syntax}
% \end{figure}


To make the intuitions developed in the previous section precise, we will now introduce a reduced calculus with support for unparameterized expression TSMs called $\miniVerseU$. 
%For reference, the syntax of $\miniVerseU$ is specified in Figure \ref{fig:lambda-tsm-syntax}. We will reproduce relevant portions of this specification inline (in tabular form) as we continue. 
We specify all formal systems in this document within the metatheoretic framework detailed in \emph{PFPL} \cite{pfpl}, and assume familiarity of fundamental background concepts (e.g. abstract binding trees, substitution, implicit identification of terms up to $\alpha$-equivalence, structural induction and rule induction) covered therein. %Familiarity with other accounts of typed lambda calculi should also suffice to understand the formal systems in this document. 

\begin{figure}
$\begin{array}{lllllll}
\textbf{Sort} & & & \textbf{Abstract Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{Typ} & \tau & ::= & t & t & \text{variable}\\
&&& \aparr{\tau}{\tau} & \parr{\tau}{\tau} & \text{partial function}\\
&&& \aall{t}{\tau} & \forallt{t}{\tau} & \text{polymorphic}\\
&&& \arec{t}{\tau} & \rect{t}{\tau} & \text{recursive}\\
&&& \aprod{\mapschema{\tau}{i}{\labelset}} & \prodt{\mapschema{\tau}{i}{\labelset}} & \text{labeled product}\\
&&& \asum{\mapschema{\tau}{i}{\labelset}} & \sumt{\mapschema{\tau}{i}{\labelset}} & \text{labeled sum}\\
\mathsf{EExp} & e & ::= & x & x & \text{variable}\\
&&& \aelam{\tau}{x}{e} & \lam{x}{\tau}{e} & \text{abstraction}\\
&&& \aeap{e}{e} & \ap{e}{e} & \text{application}\\
&&& \aetlam{t}{e} & \Lam{t}{e} & \text{type abstraction}\\
&&& \aetap{e}{\tau} & \App{e}{\tau} & \text{type application}\\
&&& \aefold{t}{\tau}{e} & \fold{e} & \text{fold}\\
&&& \aeunfold{e} & \unfold{e} & \text{unfold}\\
&&& \aetpl{\mapschema{e}{i}{\labelset}} & \tpl{\mapschema{e}{i}{\labelset}} & \text{labeled tuple}\\
&&& \aepr{\ell}{e} & \prj{e}{\ell} & \text{projection}\\
&&& \aein{\ell}{\mapschema{\tau}{i}{\labelset}}{e} & \inj{\ell}{e} & \text{injection}\\
&&& \aecase{e}{\mapschemab{x}{e}{i}{\labelset}} & \caseof{e}{\mapschemab{x}{e}{i}{\labelset}} & \text{case analysis}
\end{array}$
\caption[Syntax of types and expanded expressions in $\miniVerseU$.]{Syntax of types and expanded expressions in $\miniVerseU$. Metavariable $x$ ranges over variables, $t$ ranges over type variables, $\ell$ ranges over labels and $\labelset$ ranges over sets of labels. The forms $\mapschema{e}{i}{\labelset}$, $\mapschema{\tau}{i}{\labelset}$ and $\mapschemab{x}{e}{i}{\labelset}$ indicate finite mappings from each label $i \in \labelset$ to an expression, type or binder over an expression, respectively. The label set is omitted for concision when writing particular finite mappings, e.g. $\finmap{\mapitem{\ell_1}{e_1}, \mapitem{\ell_2}{e_2}}$. We write $\mapschema{\tau}{i}{\labelset} \otimes \ell \hookrightarrow \tau$ when $\ell \notin \labelset$ for the extension of $\mapschema{\tau}{i}{\labelset}$ with a mapping from $\ell$ to $\tau$. When we use the stylized forms $\fold{e}$ and $\inj{\ell}{e}$, we assume that the reader can infer the type information from context. }
\label{fig:U-expanded-terms}
\end{figure}


\subsection{Types and Expanded Expressions}
At the ``semantic core'' of $\miniVerseU$ are \emph{types}, $\tau$, and \emph{expanded expressions}, $e$. Their syntax is specified by the syntax chart in Figure \ref{fig:U-expanded-terms}. 
Types and expanded expressions form a language with support for partial functions, quantification over types, recursive types, and labeled product and sum types. The reader can consult \emph{PFPL} \cite{pfpl} (or another text on typed programming languages, e.g. \emph{TAPL} \cite{tapl}) for a detailed account of these constructs (or closely related variants thereof). For our purposes, it suffices to recall the following facts and definitions.

\subsubsection{Statics of Expanded Expressions}
The \emph{statics of expanded expressions} is specified by generic hypothetical judgements of the following form:

\[\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\istypeU{\Delta}{\tau} & \text{$\tau$ is a well-formed type under $\Delta$}\\
\isctxU{\Delta}{\Gamma} & \text{$\Gamma$ is a well-formed typing context under $\Delta$}\\
\hastypeU{\Delta}{\Gamma}{e}{\tau} & \text{$e$ has type $\tau$ under $\Delta$ and $\Gamma$}
\end{array}\]

\emph{Type formation contexts}, $\Delta$, are finite sets of hypotheses of the form $\Dhyp{t}$ and \emph{typing contexts}, $\Gamma$, consist of hypotheses of the form $\Ghyp{x}{\tau}$ and operate as finite mappings from variables to types. Syntactically, we write contexts as comma-separated sequences of {hypotheses} identified up to exchange and contraction. We write empty contexts as $\emptyset$ (or omit them entirely). 

The type formation judgement, $\istypeU{\Delta}{\tau}$, ensures that all free type variables in $\tau$ are tracked by $\Delta$. It is inductively defined by the following rules:
\begin{subequations}\label{rules:istypeU}
\begin{equation}
\inferrule{ }{\istypeU{\Delta, \Dhyp{t}}{t}}
\end{equation}
\begin{equation}
\inferrule{
  \istypeU{\Delta}{\tau_1}\\
  \istypeU{\Delta}{\tau_2}
}{\istypeU{\Delta}{\aparr{\tau_1}{\tau_2}}}
\end{equation}
\begin{equation}
  \inferrule{
    \istypeU{\Delta, \Dhyp{t}}{\tau}
  }{
    \istypeU{\Delta}{\aall{t}{\tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \istypeU{\Delta, \Dhyp{t}}{\tau}
  }{
    \istypeU{\Delta}{\arec{t}{\tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \{\istypeU{\Delta}{\tau_i}\}_{i \in \labelset}
  }{
    \istypeU{\Delta}{\aprod{\mapschema{\tau}{i}{\labelset}}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \{\istypeU{\Delta}{\tau_i}\}_{i \in \labelset}
  }{
    \istypeU{\Delta}{\asum{\mapschema{\tau}{i}{\labelset}}}
  }
\end{equation}
\end{subequations}
Premises of the form $\{\mathcal{J}_i\}_{i \in \labelset}$ mean that for each $i \in \labelset$, the judgement $\mathcal{J}_i$ must hold. 

The typing context formation judgement, $\isctxU{\Delta}{\Gamma}$, ensures that all types in the typing context are well-formed according to Rules (\ref{rules:istypeU}). It is inductively defined by the following rules:
\begin{subequations}\label{rules:isctxU}
\begin{equation}
  \inferrule{ }{
    \isctxU{\Delta}{\emptyset}
  }
\end{equation}
\begin{equation}\label{rule:isctxU-ext}
  \inferrule{
    \isctxU{\Delta}{\Gamma}\\
    \istypeU{\Delta}{\tau}
  }{
    \isctxU{\Delta}{\Gamma, \Ghyp{x}{\tau}}
  }
\end{equation}
\end{subequations}

The typing judgement, $\hastypeU{\Delta}{\Gamma}{e}{\tau}$, assigns types to expressions. It is inductively defined by the following rules:
\begin{subequations}\label{rules:hastypeU}
\begin{equation}
  \inferrule{ }{
    \hastypeU{\Delta}{\Gamma, \Ghyp{x}{\tau}}{x}{\tau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \istypeU{\Delta}{\tau}\\
    \hastypeU{\Delta}{\Gamma, \Ghyp{x}{\tau}}{e}{\tau'}
  }{
    \hastypeU{\Delta}{\Gamma}{\aelam{\tau}{x}{e}}{\aparr{\tau}{\tau'}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \hastypeU{\Delta}{\Gamma}{e_1}{\aparr{\tau}{\tau'}}\\
    \hastypeU{\Delta}{\Gamma}{e_2}{\tau}
  }{
    \hastypeU{\Delta}{\Gamma}{\aeap{e_1}{e_2}}{\tau'}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \hastypeU{\Delta, \Dhyp{t}}{\Gamma}{e}{\tau}
  }{
    \hastypeU{\Delta}{\Gamma}{\aetlam{t}{e}}{\aall{t}{\tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \hastypeU{\Delta}{\Gamma}{e}{\aall{t}{\tau}}\\
    \istypeU{\Delta}{\tau'}
  }{
    \hastypeU{\Delta}{\Gamma}{\aetap{e}{\tau'}}{[\tau'/t]\tau}
  }
\end{equation}
\begin{equation}
  \inferrule{\
    \istypeU{\Delta, \Dhyp{t}}{\tau}\\
    \hastypeU{\Delta}{\Gamma}{e}{[\arec{t}{\tau}/t]\tau}
  }{
    \hastypeU{\Delta}{\Gamma}{\aefold{t}{\tau}{e}}{\arec{t}{\tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \hastypeU{\Delta}{\Gamma}{e}{\arec{t}{\tau}}
  }{
    \hastypeU{\Delta}{\Gamma}{\aeunfold{e}}{[\arec{t}{\tau}/t]\tau}
  }
\end{equation}
\begin{equation}\label{rule:etpl}
  \inferrule{
    \{\hastypeU{\Delta}{\Gamma}{e_i}{\tau_i}\}_{i \in \labelset}
  }{
    \hastypeU{\Delta}{\Gamma}{\aetpl{\mapschema{e}{i}{\labelset}}}{\aprod{\mapschema{\tau}{i}{\labelset}}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \hastypeU{\Delta}{\Gamma}{e}{\aprod{\mapschema{\tau}{i}{\labelset} \otimes \ell \hookrightarrow \tau}}
  }{
    \hastypeU{\Delta}{\Gamma}{\aepr{\ell}{e}}{\tau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \{\istypeU{\Delta}{\tau_i}\}_{i \in \labelset}\\
    \istypeU{\Delta}{\tau}\\
    \hastypeU{\Delta}{\Gamma}{e}{\tau}
  }{
    \hastypeU{\Delta}{\Gamma}{\aein{\ell}{\mapschema{\tau}{i}{\labelset}\otimes \ell \hookrightarrow \tau}{e}}{\asum{\mapschema{\tau}{i}{\labelset}\otimes\ell \hookrightarrow \tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \hastypeU{\Delta}{\Gamma}{e}{\asum{\mapschema{\tau}{i}{\labelset}}}\\
    \{\hastypeU{\Delta}{\Gamma, x_i : \tau_i}{e_i}{\tau}\}_{i \in \labelset}
  }{
    \hastypeU{\Delta}{\Gamma}{\aecase{e}{\mapschemab{x}{e}{i}{\labelset}}}{\tau}
  }
\end{equation}
\end{subequations}

The rules given above validate the following standard lemmas. 

The Weakening Lemma expresses the intuition that extending a context with unused variables preserves well-formedness and typing.
\begin{lemma}[Weakening] All of the following hold: 
\begin{enumerate} 
\item If $\istypeU{\Delta}{\tau}$ then $\istypeU{\Delta, \Dhyp{t}}{\tau}$.
\item If $\isctxU{\Delta}{\Gamma}$ then $\isctxU{\Delta, \Dhyp{t}}{\Gamma}$.
\item If $\hastypeU{\Delta}{\Gamma}{e}{\tau}$ then $\hastypeU{\Delta, \Dhyp{t}}{\Gamma}{e}{\tau}$.
\item If $\hastypeU{\Delta}{\Gamma}{e}{\tau}$ and $\istypeU{\Delta}{\tau'}$ then $\hastypeU{\Delta}{\Gamma, \Ghyp{x}{\tau'}}{e}{\tau}$.
\end{enumerate}
\end{lemma}
\begin{proof-sketch}
\begin{enumerate}
\item By rule induction on Rules (\ref{rules:istypeU}).
\item By rule induction on Rules (\ref{rules:isctxU}).
\item By rule induction on Rules (\ref{rules:hastypeU}).
\item By rule induction on Rules (\ref{rules:hastypeU}).
\end{enumerate}
\end{proof-sketch}

The Substitution Lemma expresses the intuition that substitution of a type for a type variable, or an expression of the appropriate type for an expression variable, preserves well-formedness and typing. 
\begin{lemma}[Substitution] All of the following hold:
\begin{enumerate}
\item If $\istypeU{\Delta, \Dhyp{t}}{\tau}$ and $\istypeU{\Delta}{\tau'}$ then $\istypeU{\Delta}{[\tau'/t]\tau}$.
\item If $\isctxU{\Delta, \Dhyp{t}}{\Gamma}$ and $\istypeU{\Delta}{\tau'}$ then $\isctxU{\Delta}{[\tau'/t]\Gamma}$.
\item If $\hastypeU{\Delta, \Dhyp{t}}{\Gamma}{e}{\tau}$ and $\istypeU{\Delta}{\tau'}$ then $\hastypeU{\Delta}{[\tau'/t]\Gamma}{[\tau'/t]e}{[\tau'/t]\tau}$.
\item If $\hastypeU{\Delta}{\Gamma, \Ghyp{x}{\tau'}}{e}{\tau}$ and $\hastypeU{\Delta}{\Gamma}{e'}{\tau'}$ then $\hastypeU{\Delta}{\Gamma}{[e'/x]e}{\tau}$.
\end{enumerate}\end{lemma}
\begin{proof-sketch}
In each case, by rule induction on the derivation of the first assumption.
\end{proof-sketch}
The Decomposition Lemma is the converse of the Substitution Lemma.
\begin{lemma}[Decomposition] All of the following hold:
\begin{enumerate}
\item If $\istypeU{\Delta}{[\tau'/t]\tau}$ and $\istypeU{\Delta}{\tau'}$ then $\istypeU{\Delta, \Dhyp{t}}{\tau}$.
\item If $\isctxU{\Delta}{[\tau'/t]\Gamma}$ and $\istypeU{\Delta}{\tau'}$ then $\isctxU{\Delta, \Dhyp{t}}{\Gamma}$.
\item If $\hastypeU{\Delta}{[\tau'/t]\Gamma}{[\tau'/t]e}{[\tau'/t]\tau}$ and $\istypeU{\Delta}{\tau'}$ then $\hastypeU{\Delta, \Dhyp{t}}{\Gamma}{e}{\tau}$.
\item If $\hastypeU{\Delta}{\Gamma}{[e'/x]e}{\tau}$ and $\hastypeU{\Delta}{\Gamma}{e'}{\tau'}$ then $\hastypeU{\Delta}{\Gamma, \Ghyp{x}{\tau'}}{e}{\tau}$.
\end{enumerate}\end{lemma}
\begin{proof-sketch}
\begin{enumerate}
\item Type formation of $[\tau'/t]\tau$ does not depend on the structure of $\tau'$.
\item Context formation of $[\tau'/t]\Gamma$ does not depend on the structure of $\tau'$.
\item The derivation of $\hastypeU{\Delta}{[\tau'/t]\Gamma}{[\tau'/t]e}{[\tau'/t]\tau}$ does not depend on the structure of $\tau'$.
\item Typing of $[e'/x]e$ depends only on the type of $e'$ wherever it occurs, if at all.
\end{enumerate}
\end{proof-sketch}

The Regularity Lemma expresses the intuition that the type assigned to an expression under a well-formed typing context is well-formed. 
\begin{lemma}[Regularity] If $\isctxU{\Delta}{\Gamma}$ and $\hastypeU{\Delta}{\Gamma}{e}{\tau}$ then $\istypeU{\Delta}{\tau}$.\end{lemma}
\begin{proof-sketch}
By rule induction on Rules (\ref{rules:hastypeU}) and inversion of Rule (\ref{rule:isctxU-ext}). 
\end{proof-sketch}
\subsubsection{Dynamics of Expanded Expressions}
The \emph{dynamics} of expanded expressions is specified as a structural dynamics (a.k.a. structural operational semantics) by judgements of the following form:
\[\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\stepsU{e}{e'} & \text{$e$ transitions to $e'$}\\
\isvalU{e} & \text{$e$ is a value}
\end{array}\]
We also define auxiliary judgements for \emph{iterated transitions}, $\multistepU{e}{e'}$, and \emph{evaluation}, $\evalU{e}{e'}$.

\begin{definition}[Iterated Transition] Iterated transition, $\multistepU{e}{e'}$, is the reflexive, transitive closure of the transition judgement.\end{definition}

\begin{definition}[Evaluation] Evaluation, $\evalU{e}{e'}$, is derivable iff $\multistepU{e}{e'}$ and $\isvalU{e'}$. \end{definition}

Our subsequent developments do not require making reference to particular rules in the dynamics (because TSMs operate statically), so for concision, we do not produce the rules here. Instead, it suffices to state certain conditions.

The Canonical Forms condition characterizes well-typed values. We assume an \emph{eager} (i.e. \emph{by-value}) formulation of the dynamics. 
\begin{condition}[Canonical Forms]\label{condition:canonical-forms-U} If $\hastypeUC{e}{\tau}$ and $\isvalU{e}$ then:
\begin{enumerate}
\item If $\tau=\aparr{\tau_1}{\tau_2}$ then $e=\aelam{\tau_1}{x}{e'}$ and $\hastypeUCO{\Ghyp{x}{\tau_1}}{e'}{\tau_2}$.
\item If $\tau=\aall{t}{\tau'}$ then $e=\aetlam{t}{e'}$ and $\hastypeUCO{\Dhyp{t}}{e'}{\tau'}$.
\item If $\tau=\arec{t}{\tau'}$ then $e=\aefold{t}{\tau'}{e'}$ and $\hastypeUC{e'}{[\abop{rec}{t.\tau'}/t]\tau'}$. 
\item If $\tau=\aprod{\mapschema{\tau}{i}{\labelset}}$ then $e=\aetpl{\mapschema{e}{i}{\labelset}}$ and for each $i \in \labelset$ we have that $\hastypeUC{e_i}{\tau_i}$ and $\isvalU{e_i}$.
\item If $\tau=\asum{\mapschema{\tau}{i}{\labelset}}$ then $e=\aein{\ell}{\mapschema{\tau}{i}{\labelset\setminus \ell} \otimes \ell \hookrightarrow \tau'}{e'}$ and $\ell \in \labelset$ and $\hastypeUC{e'}{\tau'}$ and $\isvalU{e'}$.
\end{enumerate}\end{condition}

We also require that the statics and dynamics be coherent. This is expressed in the standard way by Preservation and Progress conditions (together, these constitute the {Type Safety} Condition). 
\begin{condition}[Preservation]\label{condition:preservation-U} If $\hastypeUC{e}{\tau}$ and $\stepsU{e}{e'}$ then $\hastypeUC{e'}{\tau}$. \end{condition}
\begin{condition}[Progress]\label{condition:progress-U} If $\hastypeUC{e}{\tau}$ then either $\isvalU{e}$ or there exists an $e'$ such that $\stepsU{e}{e'}$. \end{condition}


\subsection{Unexpanded Expressions and Typed Expansion}
Programs evaluate as expanded expressions, but programmers author \emph{unexpanded expressions}, $\ue$. The syntax of unexpanded expressions is specified by the chart in Figure \ref{fig:U-unexpanded-terms}. 

Unexpanded expressions are typed and expanded simultaneously according to the \emph{typed expansion judgement}. 
\[\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\expandsUX{\ue}{e}{\tau} & \text{$\ue$ expands to $e$ at type $\tau$ under $\Delta$ and $\Gamma$ with macro environment $\Sigma$}
\end{array}\]

\begin{figure}
$\begin{array}{lllllll}
\textbf{Sort} & & & \textbf{Abstract Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{UExp} & \ue & ::= & x & x & \text{variable}\\
&&& \aulam{\tau}{x}{\ue} & \lam{x}{\tau}{\ue} & \text{abstraction}\\
&&& \auap{\ue}{\ue} & \ap{\ue}{\ue} & \text{application}\\
&&& \autlam{t}{\ue} & \Lam{t}{\ue} & \text{type abstraction}\\
&&& \autap{\ue}{\tau} & \App{\ue}{\tau} & \text{type application}\\
&&& \aufold{t}{\tau}{\ue} & \fold{\ue} & \text{fold}\\
&&& \auunfold{\ue} & \unfold{\ue} & \text{unfold}\\
&&& \autpl{\mapschema{\ue}{i}{\labelset}} & \tpl{\mapschema{\ue}{i}{\labelset}} & \text{labeled tuple}\\
&&& \aupr{\ell}{\ue} & \prj{\ue}{\ell} & \text{projection}\\
&&& \auin{\ell}{\mapschema{\tau}{i}{\labelset}}{\ue} & \inj{\ell}{\ue} & \text{injection}\\
&&& \aucase{\ue}{\mapschemab{x}{\ue}{i}{\labelset}} & \caseof{\ue}{\mapschemab{x}{\ue}{i}{\labelset}} & \text{case analysis}\\
&&& \auletsyntax{\tau}{\ue}{\tsmv}{\ue} & \uletsyntax{\tsmv}{\tau}{\ue}{\ue} & \text{macro definition}\\
&&& \autsmap{b}{\tsmv} & \utsmap{\tsmv}{b} & \text{macro application}
\end{array}$
\caption[Syntax of unexpanded expressions in $\miniVerseU$.]{Syntax of unexpanded expressions in $\miniVerseU$. Metavariable $\tsmv$ ranges over macro identifiers and $b$ ranges over literal bodies. Literal bodies might contain unparsed subexpressions, so variable renaming and substitution cannot be defined in the usual manner over unexpanded expressions.}
\label{fig:U-unexpanded-terms}
\end{figure}
\noindent
The following rules govern the typed expansion judgement:
\begin{subequations}\label{rules:expandsU}
\begin{equation}\label{rule:expandsU-var}
  \inferrule{ }{\expandsU{\Delta}{\Gamma, x : \tau}{\Sigma}{x}{x}{\tau}}
\end{equation}
\begin{equation}
  \inferrule{
    \istypeU{\Delta}{\tau}\\
    \expandsU{\Delta}{\Gamma, x : \tau}{\Sigma}{\ue}{e}{\tau'}
  }{\expandsUX{\aulam{\tau}{x}{\ue}}{\aelam{\tau}{x}{e}}{\aparr{\tau}{\tau'}}}
\end{equation}
\begin{equation}
  \inferrule{
    \expandsUX{\ue_1}{e_1}{\aparr{\tau}{\tau'}}\\
    \expandsUX{\ue_2}{e_2}{\tau}
  }{
    \expandsUX{\auap{\ue_1}{\ue_2}}{\aeap{e_1}{e_2}}{\tau'}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \expandsU{\Delta, \Dhyp{t}}{\Gamma}{\Sigma}{\ue}{e}{\tau}
  }{
    \expandsUX{\autlam{t}{\ue}}{\aetlam{t}{e}}{\aall{t}{\tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \expandsUX{\ue}{e}{\aall{t}{\tau}}\\
    \istypeU{\Delta}{\tau'}
  }{
    \expandsUX{\autap{\ue}{\tau'}}{\aetap{e}{\tau'}}{[\tau'/t]\tau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \istypeU{\Delta, \Dhyp{t}}{\tau}\\
    \expandsUX{\ue}{e}{[\arec{t}{\tau}/t]\tau}
  }{
    \expandsUX{\aufold{t}{\tau}{\ue}}{\aefold{t}{\tau}{e}}{\arec{t}{\tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \expandsUX{\ue}{e}{\arec{t}{\tau}}
  }{
    \expandsUX{\auunfold{\ue}}{\aeunfold{e}}{[\arec{t}{\tau}/t]\tau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \{\expandsUX{\ue_i}{e_i}{\tau_i}\}_{i \in \labelset}
  }{
    \expandsUX{\autpl{\mapschema{\ue}{i}{\labelset}}}{\aetpl{\mapschema{e}{i}{\labelset}}}{\aprod{\mapschema{\tau}{i}{\labelset}}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \expandsUX{\ue}{e}{\aprod{\mapschema{\tau}{i}{\labelset}\otimes\mapitem{\ell}{\tau}}}
  }{
    \expandsUX{\aupr{\ell}{\ue}}{\aepr{\ell}{e}}{\tau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \{\istypeU{\Delta}{\tau_i}\}_{i \in \labelset}\\
    \istypeU{\Delta}{\tau}\\
    \expandsUX{\ue}{e}{\tau}
  }{
    \left\{\shortstack{$\Delta~\Gamma \vdash_\Sigma \auin{\ell}{\mapschema{\tau}{i}{\labelset}\otimes\mapitem{\ell}{\tau}}{\ue}$\\$\leadsto$\\$\aein{\ell}{\mapschema{\tau}{i}{\labelset}\otimes\mapitem{\ell}{\tau}}{e} : \asum{\mapschema{\tau}{i}{\labelset}\otimes\mapitem{\ell}{\tau}}$\vspace{-1.2em}}\right\}
  }
\end{equation}
\begin{equation}\label{rule:expandsU-case}
  \inferrule{
    \expandsUX{\ue}{e}{\asum{\mapschema{\tau}{i}{\labelset}}}\\
    \{\expandsU{\Delta}{\Gamma, \Ghyp{x_i}{\tau_i}}{\Sigma}{\ue_i}{e_i}{\tau}\}_{i \in \labelset}
  }{
    \expandsUX{\aucase{\ue}{\mapschemab{x}{\ue}{i}{\labelset}}}{\aecase{e}{\mapschemab{x}{e}{i}{\labelset}}}{\tau}
  }
\end{equation}
\begin{equation}\label{rule:usyntax}
\inferrule{
  \istypeU{\Delta}{\tau}\\
  \expandsU{\emptyset}{\emptyset}{\Sigma}{\ueparse}{\eparse}{\aparr{\tBody}{\tParseResultExp}}\\\\
  a \notin \domof{\Sigma}\\
  \expandsU{\Delta}{\Gamma}{\Sigma, \tsmenvbnd{a}{\tau}{\eparse}}{\ue}{e}{\tau'}
}{
  \expandsUX{\auletsyntax{\tau}{\ueparse}{a}{\ue}}{e}{\tau'}
}
\end{equation}
\begin{equation}\label{rule:utsmap-U}
\inferrule{
  \encodeBody{b}{\ebody}\\
  \evalU{\ap{\eparse}{\ebody}}{\inj{\lbltxt{Success}}{\ecand}}\\
  \decodeCondE{\ecand}{\ce}\\\\
  \cvalidE{\emptyset}{\emptyset}{\spctx{\Delta}{\Gamma}{\Sigma, \tsmenvbnd{a}{\tau}{\eparse}}{b}}{\ce}{e}{\tau}
}{
  \expandsU{\Delta}{\Gamma}{\Sigma, \tsmenvbnd{a}{\tau}{\eparse}}{\autsmap{b}{a}}{e}{\tau}
}
\end{equation}
\end{subequations}
Notice that each form of expanded expression (Figure \ref{fig:U-expanded-terms}) corresponds to a form of unexpanded expression (Figure \ref{fig:U-unexpanded-terms}). For each typing rule in Rules (\ref{rules:hastypeU}), there is a corresponding typed expansion rule -- Rules (\ref{rule:expandsU-var}) through (\ref{rule:expandsU-case}) -- where the unexpanded and expanded forms correspond. The premises also correspond -- if a typing judgement appears as a premise of a typing rule, then the corresponding premise in the corresponding typed expansion rule is the corresponding typed expansion judgement. The macro environment is not extended or inspected by these rules (it is only ``threaded through'' them opaquely).

There are two forms of unexpanded expressions that do not correspond to forms of expanded expressions: the macro definition form, and the macro application form. These two forms are the topic of the next two subsections, respectively.

\subsection{Macro Definition}
The \emph{macro definition form}: $$\uletsyntax{a}{\tau}{\ueparse}{\ue}$$ allows the programmer to introduce a {macro} identified as $a$ at type $\tau$ with \emph{unexpanded parse function} $\ueparse$ into the macro environment of $\ue$. The abstract form corresponding to this stylized form is $\auletsyntax{\tau}{\ueparse}{a}{\ue}$. 
The premises of Rule (\ref{rule:usyntax}), which governs this form, can be understood as follows, in order:
\begin{enumerate}
\item The first premise ensures that the type annotation specifies a well-formed type, $\tau$.
\item The second premise types and expands the \emph{unexpanded parse function}, $\ueparse$, to produce the \emph{expanded parse function}, $\eparse$. Notice that this occurs under empty contexts, i.e. parse functions cannot refer to the surrounding variable bindings. This is because parse functions are evaluated when a macro is applied during the typed expansion process (as we will discuss momentarily), not during evaluation of the program they appear within. Parse functions must be of type \[\aparr{\tBody}{\tParseResultExp}\] where 
$\tParseResultExp$ abbreviates the following labeled sum type\footnote{In VerseML, the \li{ParseError} constructor required an error message and an error location, but we omit these in our formalization for simplicity}:
\[
\tParseResultExp \triangleq [\mapitem{\lbltxt{Success}}{\tCEExp}, \mapitem{\lbltxt{ParseError}}{\prodt{}}]
\] and 
 $\tBody$ and $\tCEExp$ abbreviate types that we will characterize below. 
\item The third premise of Rule (\ref{rule:usyntax}) checks that there is not already a macro identified as $a$ in the macro environment, $\Sigma$. 

Macro environments are finite mappings from macro identifiers to \emph{expanded macro definitions}, $\xtsmdef{\tau}{\eparse}$, where $\tau$ is the macro's type annotation and $\eparse$ is the macro's \emph{expanded parse function}. The \emph{macro environment formation} judgement, $\macenvOK{\Delta}{\Sigma}$, ensures that the type annotations are well-formed under $\Delta$ and the parse functions are of type $\aparr{\tBody}{\tParseResultExp}$.
\[\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\macenvOK{\Delta}{\Sigma} & \text{Macro environment $\Sigma$ is well-formed under $\Delta$.}\end{array}\]
This judgement is inductively defined by the following rules:
\begin{subequations}[intermezzo]
\begin{equation}
\inferrule{ }{\macenvOK{\Delta}{\emptyset}}
\end{equation}
\begin{equation}
\inferrule{
  \macenvOK{\Delta}{\Sigma}\\\\
  \istypeU{\Delta}{\tau}\\
  \hastypeU{\emptyset}{\emptyset}{\eparse}{\aparr{\tBody}{\tParseResultExp}}
}{
  \macenvOK{\Delta}{\Sigma, \tsmenvbnd{a}{\tau}{\eparse}}
}
\end{equation}
\end{subequations}
\item 
The fourth premise of Rule (\ref{rule:usyntax}) extends the macro environment with the newly determined expanded macro definition and proceeds to produce a type, $\tau'$, and expansion, $e$, for $\ue$.
\end{enumerate}
The conclusion of the rule gives $\tau'$ and $e$ as the type and expansion of the expression as a whole.

\subsection{Macro Application}
The last form of unexpanded expression is the form for applying a macro identified as $a$ to a literal form with literal body $b$:
\[
\utsmap{a}{b}
\] 
The abstract form corresponding to this stylized form is $\autsmap{b}{a}$, i.e. for each literal body, $b$, there is an operator $\texttt{utsmap}[b]$, indexed by the macro identifier $a$ and taking no arguments. The premises of Rule (\ref{rule:utsmap-U}), which governs this form, can be understood as follows, in order:
\begin{enumerate}
\item The \emph{body encoding judgement} $\encodeBody{b}{\ebody}$ specifies a mapping from the literal body, $b$, to an expanded value, $\ebody$, of type $\tBody$. An inverse mapping is specified by the \emph{body decoding judgement} $\decodeBody{\ebody}{b}$.
\[\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\encodeBody{b}{e} & \text{$b$ encodes to $e$}\\
\decodeBody{e}{b} & \text{$e$ decodes to $b$}
\end{array}\]
Rather than picking a particular definition of $\tBody$ and inductively defining these judgements against it, we simply state the following sufficient conditions, which establish an isomorphism between literal bodies and values of type $\tBody$.
\begin{condition}[Body Encoding] For every literal body $b$, we have that $\encodeBody{b}{\ebody}$ and $\hastypeUC{\ebody}{\tBody}$ and $\isvalU{\ebody}$. \end{condition}
\begin{condition}[Body Decoding] If $\hastypeUC{\ebody}{\tBody}$ and $\isvalU{\ebody}$ then $\decodeBody{\ebody}{b}$ for some $b$. \end{condition}
\begin{condition}[Body Encoding Inverse] If $\encodeBody{b}{\ebody}$ then $\decodeBody{\ebody}{b}$. \end{condition}
\begin{condition}[Body Decoding Inverse] If $\hastypeUC{\ebody}{\tBody}$ and $\isvalU{\ebody}$ and $\decodeBody{\ebody}{b}$ then $\encodeBody{b}{\ebody}$. \end{condition}
\begin{condition}[Body Encoding Uniqueness] If $\encodeBody{b}{\ebody}$ and $\encodeBody{b}{\ebody'}$ then $\ebody = \ebody'$. \end{condition}
\begin{condition}[Body Decoding Uniqueness] If $\hastypeUC{\ebody}{\tBody}$ and $\isvalU{\ebody}$ and $\decodeBody{\ebody}{b}$ and $\decodeBody{\ebody}{b'}$ then $b=b'$. \end{condition}

\item The second premise applies the expanded parse function $\eparse$ associated with $a$ in the macro environment to $\ebody$. If parsing succeeds, i.e. a value of the (stylized) form $\inj{\lbltxt{Success}}{\ecand}$ results from evaluation, then $\ecand$ will be a value of type $\tCEExp$ (assuming a well-formed macro environment and by the definition of evaluation, transitive application of the Preservation Assumption \ref{condition:preservation-U} and the Canonical Forms Assumption \ref{condition:canonical-forms-U}). We call $\ecand$ the \emph{encoding of the candidate expansion}.

If the parse function produces a value labeled $\lbltxt{ParseError}$, then typed expansion fails. No rule is necessary to handle this case. 

\item The judgement $\decodeCondE{\ecand}{\ce}$ decodes the encoding of the candidate expansion, i.e. it maps $\ecand$ onto a \emph{candidate expansion expression}, $\ce$. The syntax of candidate expansion expressions and \emph{candidate expansion types}, $\ctau$, which can occur within candidate expansion expressions, is specified in Figure \ref{fig:U-candidate-terms}. The inverse mapping is specified by the judgement $\encodeCondE{\ce}{\ecand}$. 
\[\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\decodeCondE{e}{\ce} & \text{$e$ decodes to $\ce$}\\
\encodeCondE{\ce}{e} & \text{$\ce$ encodes to $e$}
\end{array}\]

As with type $\tBody$, rather than defining the type $\tCEExp$ explicitly, and these judgements inductively, we give  the following sufficient conditions. These establish an isomorphism between values of type $\tCEExp$ and candidate expansion expressions.

\begin{condition}[Candidate Expansion Decoding] If $\hastypeUC{\ecand}{\tCEExp}$ and $\isvalU{\ecand}$ then $\decodeCondE{\ecand}{\ce}$ for some $\ce$. \end{condition}
\begin{condition}[Candidate Expansion Encoding] For every $\ce$, we have $\encodeCondE{\ce}{\ecand}$ such that $\hastypeUC{\ecand}{\tCEExp}$ and $\isvalU{\ecand}$. \end{condition}
\begin{condition}[Candidate Expansion Decoding Inverse] If $\hastypeUC{\ecand}{\tCEExp}$ and $\isvalU{\ecand}$ and $\decodeCondE{\ecand}{\ce}$ then $\encodeCondE{\ce}{\ecand}$. \end{condition}
\begin{condition}[Candidate Expansion Encoding Inverse] If $\encodeCondE{\ce}{\ecand}$ then $\decodeCondE{\ce}{\ecand}$. \end{condition}
\begin{condition}[Candidate Expansion Decoding Uniqueness] If $\hastypeUC{\ecand}{\tCEExp}$ and $\isvalU{\ecand}$ and $\decodeCondE{\ecand}{\ce}$ and $\decodeCondE{\ecand}{\ce'}$ then $\ce=\ce'$. \end{condition}
\begin{condition}[Candidate Expansion Encoding Uniqueness] If $\encodeCondE{\ce}{\ecand}$ and $\encodeCondE{\ce}{\ecand'}$ then $\ecand=\ecand'$. \end{condition}

\item The final premise of Rule (\ref{rule:utsmap-U}) \emph{validates} the candidate expansion and simultaneously generates the \emph{final expansion}, $e$, according to the \emph{candidate expansion expression validation judgement}, described next.
\end{enumerate}

\subsection{Candidate Expansion Validation}
\begin{figure}
$\begin{array}{lllllll}
\textbf{Sort} & & & \textbf{Abstract Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{CETyp} & \ctau & ::= & t & t & \text{variable}\\
&&& \aceparr{\ctau}{\ctau} & \parr{\ctau}{\ctau} & \text{partial function}\\
&&& \aceall{t}{\ctau} & \forallt{t}{\ctau} & \text{polymorphic}\\
&&& \acerec{t}{\ctau} & \rect{t}{\ctau} & \text{recursive}\\
&&& \aceprod{\mapschema{\ctau}{i}{\labelset}} & \prodt{\mapschema{\ctau}{i}{\labelset}} & \text{labeled product}\\
&&& \acesum{\mapschema{\ctau}{i}{\labelset}} & \sumt{\mapschema{\ctau}{i}{\labelset}} & \text{labeled sum}\\
&&& \acesplicedt{m}{n} & \splicedt{m}{n} & \text{spliced}\\
\mathsf{CEExp} & \ce & ::= & x & x & \text{variable}\\
&&& \acelam{\ctau}{x}{\ce} & \lam{x}{\ctau}{\ce} & \text{abstraction}\\
&&& \aceap{\ce}{\ce} & \ap{\ce}{\ce} & \text{application}\\
&&& \acetlam{t}{\ce} & \Lam{t}{\ce} & \text{type abstraction}\\
&&& \acetap{\ce}{\ctau} & \App{\ce}{\ctau} & \text{type application}\\
&&& \acefold{t}{\ctau}{\ce} & \fold{\ce} & \text{fold}\\
&&& \aceunfold{\ce} & \unfold{\ce} & \text{unfold}\\
&&& \acetpl{\mapschema{\ce}{i}{\labelset}} & \tpl{\mapschema{\ce}{i}{\labelset}} & \text{labeled tuple}\\
&&& \acepr{\ell}{\ce} & \prj{\ce}{\ell} & \text{projection}\\
&&& \acein{\ell}{\mapschema{\ctau}{i}{\labelset}}{\ce} & \inj{\ell}{\ce} & \text{injection}\\
&&& \acecase{\ce}{\mapschemab{x}{\ce}{i}{\labelset}} & \caseof{\ce}{\mapschemab{x}{\ce}{i}{\labelset}} & \text{case analysis}\\
&&& \acesplicede{m}{n} & \splicede{m}{n} & \text{spliced}
\end{array}$
\caption[Syntax of candidate expansion types and expressions in $\miniVerseU$.]{Syntax of candidate expansion types, $\ctau$ (pronounced ``grave $\tau$''), and expressions, $\ce$ (pronounced ``grave $e$''), in $\miniVerseU$. Metavariables $m$ and $n$ range over natural numbers.}
\label{fig:U-candidate-terms}
\end{figure}

The \emph{candidate expansion validation judgements} validate candidate expansion types, $\ctau$, and expressions, $\ce$, and simultaneously generate their final expansions.
\[\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\cvalidT{\Delta}{\spctxv}{\ctau}{\tau} & \text{Candidate expansion type $\ctau$ expands to $\tau$ under $\Delta$ and }\\
& \text{splicing scene $\spctxv$.}\\
\cvalidE{\Delta}{\Gamma}{\spctxv}{\ce}{e}{\tau} & \text{Candidate expansion expression $\ce$ expands to $e$ at type $\tau$}\\
& \text{under $\Delta$, $\Gamma$ and splicing scene $\spctxv$.}
\end{array}\]
\emph{Splicing scenes}, $\spctxv$, are of the form $\Delta; \Gamma; \Sigma; b$. They consist of the type formation context, $\Delta$, the typing context, $\Gamma$, the macro environment, $\Sigma$, and the literal body, $b$, from the macro application site (cf. Rule (\ref{rule:utsmap-U})).

\subsubsection{Candidate Expansion Type Validation}

The \emph{candidate expansion type validation judgement}, $\cvalidT{\Delta}{\spctxv}{\ctau}{\tau}$, is inductively defined by the following rules:
\begin{subequations}\label{rules:cvalidT-U}
\begin{equation}\label{rule:cvalidT-U-tvar}
\inferrule{ }{
  \cvalidT{\Delta, \Dhyp{t}}{\spctxv}{t}{t}
}
\end{equation}
\begin{equation}
  \inferrule{
    \cvalidT{\Delta}{\spctxv}{\ctau_1}{\tau_1}\\
    \cvalidT{\Delta}{\spctxv}{\ctau_2}{\tau_2}
  }{
    \cvalidT{\Delta}{\spctxv}{\aceparr{\ctau_1}{\ctau_2}}{\aparr{\tau_1}{\tau_2}}
  }
\end{equation}
\begin{equation}
  \inferrule {
    \cvalidT{\Delta, \Dhyp{t}}{\spctxv}{\ctau}{\tau}
  }{
    \cvalidT{\Delta}{\spctxv}{\aceall{t}{\ctau}}{\aall{t}{\tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \cvalidT{\Delta, \Dhyp{t}}{\spctxv}{\ctau}{\tau}
  }{
    \cvalidT{\Delta}{\spctxv}{\acerec{t}{\ctau}}{\arec{t}{\tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \{\cvalidT{\Delta}{\spctxv}{\ctau_i}{\tau_i}\}_{i \in \labelset}
  }{
    \cvalidT{\Delta}{\spctxv}{\aceprod{\mapschema{\ctau}{i}{\labelset}}}{\aprod{\mapschema{\tau}{i}{\labelset}}}
  }
\end{equation}
\begin{equation}\label{rule:cvalidT-U-sum}
  \inferrule{
    \{\cvalidT{\Delta}{\spctxv}{\ctau_i}{\tau_i}\}_{i \in \labelset}
  }{
    \cvalidT{\Delta}{\spctxv}{\acesum{\mapschema{\ctau}{i}{\labelset}}}{\asum{\mapschema{\tau}{i}{\labelset}}}
  }
\end{equation}
\begin{equation}\label{rule:acesplicedt}
  \inferrule{
    \parseTyp{\bsubseq{b}{m}{n}}{\tau}\\
    \Delta \cap \Delta_S = \emptyset\\
    \istypeU{\Delta_S}{\tau}
  }{
    \cvalidT{\Delta}{\spctx{\Gamma_S}{\Delta_S}{\Sigma_S}{b}}{\acesplicedt{m}{n}}{\tau}
  }
\end{equation}
\end{subequations}
Each form of type, $\tau$, corresponds to a form of candidate expansion type, $\ctau$ (compare Figures \ref{fig:U-expanded-terms} and \ref{fig:U-candidate-terms}). For each type formation rule in Rules (\ref{rules:istypeU}), there is a corresponding candidate expansion type validation rule -- Rules (\ref{rule:cvalidT-U-tvar}) to (\ref{rule:cvalidT-U-sum}) -- where the candidate expansion type and the final expansion correspond. The premises also correspond. 


The only form of candidate expansion type that does not correspond to a form of type is $\acesplicedt{m}{n}$, which is a \emph{reference to a spliced type}, i.e. it indicates that a type should be parsed out from the literal body, $b$, beginning at position $m$ and ending at position $n$. Rule (\ref{rule:acesplicedt}) governs this form. The first premise extracts the indicated subsequence of $b$ (using the metafunction $\bsubseq{b}{m}{n}$) and parses it (using the metafunction $\mathsf{parseTyp}(b)$) to produce the spliced type, $\tau$. We assume sensible definitions of these metafunctions.

 The third premise of Rule (\ref{rule:acesplicedt}) checks that $\tau$ is well-formed under the application site type formation context, $\Delta_S$. The second premise requires that the expansion's type formation context, $\Delta$, be disjoint from the application site type formation context, $\Delta_S$. This can always be achieved by alpha-varying the candidate expansion type that the reference to the spliced type appears within. Such a change in bound variable names cannot ``leak into'' spliced types because the hypotheses in $\Delta$ are not made available to the spliced type $\tau$. This achieves the \emph{expansion independent splicing} property described in Sec. \ref{sec:splicing-and-hygiene} for type variables.

Notice also that Rule (\ref{rule:acesplicedt}) is the only rule where $\Delta_S$ appears. This achieves the \emph{context-independent expansion} property described in Sec. \ref{sec:splicing-and-hygiene} for type variables.

\subsubsection{Candidate Expansion Expression Validation}
The \emph{candidate expansion expression validation judgement}, $\cvalidE{\Delta}{\Gamma}{\spctxv}{\ce}{e}{\tau}$, is inductively defined by the following rules: 
\begin{subequations}\label{rules:cvalidE-U}
\begin{equation}\label{rule:cvalidE-var}
\inferrule{ }{
  \cvalidE{\Delta}{\Gamma, \Ghyp{x}{\tau}}{\spctxv}{x}{x}{\tau}
}
\end{equation}
\begin{equation}
\inferrule{
  \cvalidT{\Delta}{\spctxv}{\ctau}{\tau}\\
  \cvalidE{\Delta}{\Gamma, \Ghyp{x}{\tau}}{\spctxv}{\ce}{e}{\tau'}
}{
  \cvalidE{\Delta}{\Gamma}{\spctxv}{\acelam{\ctau}{x}{\ce}}{\aelam{\tau}{x}{e}}{\aparr{\tau}{\tau'}}
}
\end{equation}
\begin{equation}
  \inferrule{
    \cvalidE{\Delta}{\Gamma}{\spctxv}{\ce_1}{e_1}{\aparr{\tau}{\tau'}}\\
    \cvalidE{\Delta}{\Gamma}{\spctxv}{\ce_2}{e_2}{\tau}
  }{
    \cvalidE{\Delta}{\Gamma}{\spctxv}{\aceap{\ce_1}{\ce_2}}{\aeap{e_1}{e_2}}{\tau'}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \cvalidE{\Delta, \Dhyp{t}}{\Gamma}{\spctxv}{\ce}{e}{\tau}
  }{
    \cvalidEX{\acetlam{t}{\ce}}{\aetlam{t}{e}}{\aall{t}{\tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \cvalidEX{\ce}{e}{\aall{t}{\tau}}\\
    \cvalidT{\Delta}{\spctxv}{\ctau'}{\tau'}
  }{
    \cvalidEX{\acetap{\ce}{\ctau'}}{\aetap{e}{\tau'}}{[\tau'/t]\tau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \cvalidT{\Delta, \Dhyp{t}}{\spctxv}{\ctau}{\tau}\\
    \cvalidEX{\ce}{e}{[\arec{t}{\tau}/t]\tau}
  }{
    \cvalidEX{\acefold{t}{\ctau}{\ce}}{\aefold{t}{\tau}{e}}{\arec{t}{\tau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \cvalidEX{\ce}{e}{\arec{t}{\tau}}
  }{
    \cvalidEX{\aceunfold{\ce}}{\aeunfold{e}}{[\arec{t}{\tau}/t]\tau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \{\cvalidEX{\ce_i}{e_i}{\tau_i}\}_{i \in \labelset}
  }{
    \cvalidEX{\acetpl{\mapschema{\ce}{i}{\labelset}}}{\aetpl{\mapschema{e}{i}{\labelset}}}{\aprod{\mapschema{\tau}{i}{\labelset}}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \cvalidEX{\ce}{e}{\aprod{\mapschema{\tau}{i}{\labelset}\otimes\mapitem{\ell}{\tau}}}
  }{
    \cvalidEX{\acepr{\ell}{\ce}}{\aepr{\ell}{e}}{\tau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \{\cvalidT{\Delta}{\spctxv}{\ctau_i}{\tau_i}\}_{i \in \labelset}\\
    \cvalidT{\Delta}{\spctxv}{\ctau}{\tau}\\
    \cvalidEX{\ce}{e}{\tau}
  }{
    \left\{\shortstack{$\Delta~\Gamma \vdash_\Sigma \acein{\ell}{\mapschema{\ctau}{i}{\labelset}\otimes\mapitem{\ell}{\ctau}}{\ce}$\\$\leadsto$\\$\aein{\ell}{\mapschema{\tau}{i}{\labelset}\otimes\mapitem{\ell}{\tau}}{e} : \asum{\mapschema{\tau}{i}{\labelset}\otimes\mapitem{\ell}{\tau}}$\vspace{-1.2em}}\right\}
  }
\end{equation}
\begin{equation}\label{rule:cvalidE-case}
  \inferrule{
    \cvalidEX{\ce}{e}{\asum{\mapschema{\tau}{i}{\labelset}}}\\
    \{\cvalidE{\Delta}{\Gamma, \Ghyp{x_i}{\tau_i}}{\spctxv}{\ue_i}{e_i}{\tau}\}_{i \in \labelset}
  }{
    \cvalidEX{\acecase{\ce}{\mapschemab{x}{\ce}{i}{\labelset}}}{\aecase{e}{\mapschemab{x}{e}{i}{\labelset}}}{\tau}
  }
\end{equation}
\begin{equation}\label{rule:cvalidE-splicede}
\inferrule{
  \parseUExp{\bsubseq{b}{m}{n}}{\ue}\\\\
  \Delta \cap \Delta_S = \emptyset\\
  \domof{\Gamma} \cap \domof{\Gamma_S} = \emptyset\\
  \expandsU{\Delta_S}{\Gamma_S}{\Sigma_S}{\ue}{e}{\tau}
}{
  \cvalidE{\Delta}{\Gamma}{\spctx{\Delta_S}{\Gamma_S}{\Sigma_S}{b}}{\acesplicede{m}{n}}{e}{\tau}
}
\end{equation}
\end{subequations}

Each form of expanded expression, $e$, corresponds to a form of candidate expansion expression, $\ce$ (compare Figures \ref{fig:U-expanded-terms}). For each typing rule in Rules \ref{rules:hastypeU}, there is a corresponding candidate expansion expression validation rule -- Rules (\ref{rule:cvalidE-var}) to (\ref{rule:cvalidE-case}) -- where the candidate expansion expression and expanded expression correspond. The premises also correspond.

The only form of candidate expansion expression that does not correspond to a form of expanded expression is $\acesplicede{m}{n}$, which is a \emph{reference to a spliced unexpanded expression}, i.e. it indicates that an unexpanded expression should be parsed out from the literal body, $b$, beginning at position $m$ and ending at position $n$. Rule (\ref{rule:cvalidE-splicede}) governs this form. The first premise extracts the indicated subsequence of $b$ (using the metafunction $\bsubseq{b}{m}{n}$) and parses it (using the metafunction $\mathsf{parseUExp}(b)$) to produce the spliced unexpanded expression, $\ue$. We assume sensible definitions of these metafunctions.

The final premise of Rule (\ref{rule:cvalidE-splicede}) types and expands the spliced unexpanded expression $\ue$ under the application site contexts, $\Delta_S$ and $\Gamma_S$, and macro environment, $\Sigma_S$. The second premise requires that the expansion's type formation context, $\Delta$, be disjoint from the application site type formation context, $\Delta_S$. Similarly, the third premise requires that the expansion's typing context, $\Gamma$, be disjoint from the application site typing context, $\Gamma_S$. These requirements can always be satisfied by alpha-varying the candidate expansion expression that the reference to the spliced unexpanded expression appears within. Such a change in bound variable names cannot ``leak into'' spliced unexpanded expressions because the hypotheses in $\Delta$ and $\Gamma$ are not  available to the spliced unexpanded expression $\ue$. This achieves the \emph{expansion independent splicing} property described in Sec. \ref{sec:splicing-and-hygiene} for variables, type variables and macro identifiers.

Notice also that Rule (\ref{rule:cvalidE-splicede}) is the only rule where $\Delta_S$, $\Gamma_S$ and $\Sigma_S$ appear. This achieves the context-independent expansion property described in Sec. \ref{sec:splicing-and-hygiene} for variables, type variables and macro identifiers.


\subsection{Metatheory}
For the rules we have given to be sensible, we must have that typed expansion produces an expansion of the expected type. Formally, this can be stated by the following theorem.

\begin{theorem}[Typed Expansion]\label{thm:typed-expansion-U}
If $\expandsU{\Delta}{\Gamma}{\Sigma}{\ue}{e}{\tau}$ and $\isctxU{\Delta}{\Gamma}$ and $\macenvOK{\Delta}{\Sigma}$ then $\hastypeU{\Delta}{\Gamma}{e}{\tau}$. 
\end{theorem}

A typed expansion judgement appears as a premise in candidate expansion expression validation Rule (\ref{rule:cvalidE-splicede}), and a candidate expansion expression validation judgement appears as a premise in typed expansion Rule (\ref{rule:utsmap-U}), so Rules (\ref{rules:expandsU}) and Rules (\ref{rules:cvalidE-U}) must be mutually defined. We must also define the following theorem about candidate expansion expression validation mutually with Theorem \ref{thm:typed-expansion-U}. 
\begin{theorem}[Candidate Expansion Expression Validation]\label{thm:candidate-expansion-validation-U}
If $\cvalidE{\Delta}{\Gamma}{\spctx{\Delta_S}{\Gamma_S}{\Sigma_S}{b}}{\ce}{e}{\tau}$ and $\isctxU{\Delta}{\Gamma}$ and $\isctxU{\Delta_S}{\Gamma_S}$ and $\macenvOK{\Delta_S}{\Sigma_S}$ then $\hastypeU{\Dcons{\Delta}{\Delta_S}}{\Gcons{\Gamma}{\Gamma_S}}{e}{\tau}$.
\end{theorem}

Proving Theorem \ref{thm:candidate-expansion-validation-U} first requires the following lemma about candidate expansion type validation.
\begin{lemma}[Candidate Expansion Type Validation]\label{lemma:candidate-expansion-type-validation}
If $\cvalidT{\Delta}{\spctx{\Delta_S}{\Gamma_S}{\Sigma_S}{b}}{\ctau}{\tau}$ then $\istypeU{\Dcons{\Delta}{\Delta_S}}{\tau}$.
\end{lemma}

\chapter{Unparameterized Pattern TSMs}\label{sec:pattern-tsms}
\section{Pattern TSMs By Example}
TSMs as we have described them so far decrease the syntactic cost of introducing a value at a specified type. In full-scale functional languages like ML, one typically deconstructs a value using \emph{nested pattern matching}. For example, let us return to the definition of the datatype \lstinline{Rx} shown at the beginning of Sec. \ref{sec:examples}. We can pattern match over a value, \lstinline{r}, of type \lstinline{Rx} using VerseML's \lstinline{match} construct like this:
\begin{lstlisting}[numbers=none]
match r with 
    Seq(Str(name), Seq(Str ": ", ssn)) => display name ssn
  |  _ => raise Invalid
\end{lstlisting}
In a functional language with primitive support for regular expression pattern syntax, we would expect to be able to write this example more concisely using the splicing forms discussed in Sec. \ref{sec:tsms-by-example}:
\begin{lstlisting}[numbers=none]
match r with 
    /SURL@EURLnameSURL: %EURLssn/ => display name ssn
  | _ => raise Invalid
\end{lstlisting}

Patterns are not expressions, so we cannot simply use a TSM defined at type \lstinline{Rx} in a pattern. To address this, we must extend our language with support for typed pattern syntax macros (TPSMs). TPSMs are entirely analagous to TSMs, differing primarily in that the expansions they generate are patterns, rather than expressions. Assuming the abstract syntax of patterns is encoded by the type \lstinline{Pat} (analagous to \lstinline{Exp}), we can define a TPSM at type \lstinline{Rx} as follows:
\begin{lstlisting}[numbers=none]
pattern syntax rx at Rx {
	static fn (body : Body) : Pat => 
	  (* regex pattern parser here *)
}
\end{lstlisting}

Using this TPSM, we can rewrite our example as follows:
\begin{lstlisting}[numbers=none]
match r with 
    rx /SURL@EURLnameSURL: %EURLssn/ => display name ssn
  | _ => raise Invalid
\end{lstlisting}
To ensure that the client of the TPSM need not ``guess at'' what variables are bound by the pattern, variables (e.g. \lstinline{name} and \lstinline{ssn} here) can only appear in spliced subpatterns (just as variables bound at the use site can only appear in spliced subexpressions when using TSMs). We leave a formal account of TPSMs (in a reduced calculus that features simple pattern matching) as work that remains to be completed (see Sec. \ref{sec:syntax-timeline}).

ML does not presently support pattern matching over values of an abstract data type. However, there have been proposals for adding support for pattern matching over abstract data types defined by modules having a ``datatype-like'' shape, e.g. those that define a case analysis function like the one specified by \lstinline{RX}, shown in Sec. \ref{sec:examples}. We leave further discussion of such a facility and of parameterized TPSMs also as remaining work (see Sec. \ref{sec:syntax-timeline}). 

\subsection{Usage}
\subsection{Definition}
\subsection{Splicing and Binding}
\subsection{Validation}

\section{$\miniVersePat$}
\subsection{Types, Expanded Patterns and Expanded Expressions}
\subsection{Macro Expansion and Validation}
\subsection{Metatheory}

\chapter{Parameterized TSMs}\label{sec:tsms-parameterized}
\section{Parameterized TSMs By Example}
\subsection{Value Parameters By Example}
\subsection{Type Parameters By Example}
\subsection{Module Parameters By Example}
\section{$\miniVerseParam$}
\subsection{Signatures, Types and Expanded Expressions}
\subsection{Parameter Application and Deferred Substitution}
\subsection{Macro Expansion and Validation}
\subsection{Metatheory}


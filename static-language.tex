% !TEX root = omar-thesis.tex
\chapter{Static Evaluation}\label{chap:static-eval}
In the previous chapters, we have assumed that the parse functions in TSM definitions are closed expanded expressions. This is unrealistic in practice -- writing a parser generally requires access to various libraries. Moreover, the parse function might itself be written more concisely using TSMs. In this chapter, we address these problems by introducing a \emph{static environment} shared between parse functions.

\section{Static Values}
Figure \ref{fig:static-module-example} shows an example of a module, \li{ParserCombos} (see Sec. \ref{sec:parser-combinators}), bound \emph{statically} for use within the static parse functions in the subsequent TSM definitions.
\begin{figure}[h]
\begin{lstlisting}
static module ParserCombos = 
struct 
  type parser('c, 't) = list('c) -> list('t * list('c))
  val alt : parser('c, 't) -> parser('c, 't) -> parser('c, 't)
  (* ... *)
end

syntax $a at T by 
  static fn(b) => 
  	(* ... *) ParserCombos.alt (* ... *)
end

syntax $b at T' by 
  static fn(b) => 
    (* ... *) ParserCombos.alt (* ... *)
end

val y = (* ParserCombos CANNOT be used here *)
\end{lstlisting}
\caption{Binding a static module for use within parse functions.}
\label{fig:static-module-example}
\end{figure}
\clearpage

\li{ParserCombos} can only be used within other static values (e.g. the parse functions.) Static values do not persist from ``compile-time'' to ``run-time'', so we cannot use \li{ParserCombos} when giving the value of \li{y} on the last line. This distinguishes our approach from that taken by staged computation systems \cite{Taha99multi-stageprogramming:}. Notionally, static values operate much like a read-evaluate-print loop (REPL), in that they are evaluated immediately and the evaluated values are tracked by a \emph{static environment}.


\section{Applying TSMs Within TSM Definitions}\label{sec:tsms-for-tsms}
TSMs and TSM abbreviations can also be qualified as \li{static} and then used within parse functions and other static terms. Let us consider some examples of particular relevance to TSM providers.

\subsection{Quasiquotation}
TSMs must generate values of type \li{proto_expr} or \li{proto_pat}. Constructing values of these types explicitly can have high syntactic cost. To decrease the syntactic cost of constructing values of these types, we can define TSMs that provide support for \emph{quasiquotation syntax} (similar to that built in to languages like Lisp \cite{Bawd99a} and Scala \cite{shabalin2013quasiquotes}):
\begin{lstlisting}[numbers=none]
static syntax $proto_expr at proto_expr {
  static fn(b) => 
    (* proto-expression quasiquotation parser here *)
}

static syntax $proto_pat at proto_pat {
  static fn(b) => 
    (* proto-pattern quasiquotation parser here *)
}
\end{lstlisting}
For example, the following expression:
\begin{lstlisting}[numbers=none]
val gx = $proto_expr `SQTg(x)EQT`
\end{lstlisting}
is more concise than its expansion:
\begin{lstlisting}[numbers=none]
val gx = App(Var 'SSTRgESTR', Var 'SSTRxESTR')
\end{lstlisting}
Anti-quotation, i.e. splicing in an expression of type \li{proto_expr} (or \li{proto_pat}), is performed by prefixing a variable or parenthesized expression with \li{%}:
\begin{lstlisting}[numbers=none]
val fgx = $proto_expr `SQTf(%EQTgxSQT)EQT`
\end{lstlisting}
The expansion of this term is:
\begin{lstlisting}[numbers=none]
val fgx = App(Var 'SSTRfESTR', gx)
\end{lstlisting}

\subsection{Grammar-Based Parser Generators}
In Sec. \ref{sec:grammars}, we discussed a number of grammar-based parser generators. Abstractly, a parser generator is a module matching the signature \li{PARSEGEN} defined in Figure \ref{fig:PARSEGEN}.

\begin{figure}
\begin{lstlisting}
signature PARSEGEN = 
sig 
  type grammar('a)
  (* ... operations on grammars ... *)
  type parser('a) = string -> 'a parse_result
  val generate : grammar('a) -> parser('a)
end
\end{lstlisting}
\vspace{-8px}
\caption{A signature for parser generators.}
\vspace{-8px}
\label{fig:PARSEGEN}
\end{figure}

Rather than constructing a grammar using various operations (whose specifications are elided in \li{PARSEGEN}), we wish to use a syntax for grammars that follows standard conventions. We can do so by defining a parametric TSM \li{#\dolla#grammar}, qualified so as to be usable in the static phase, as follows:
\begin{lstlisting}[numbers=none]
static syntax $grammar (P : PARSEGEN) 'a at P.grammar('a) by 
  static fn(b) => (* ... *)
end
\end{lstlisting}

Using this definition, and given a module \li{P : PARSEGEN} and a static value defining the grammar of spliced unexpanded expressions, \li{spliced_uexp : P.grammar(proto_expr)}, we can define a TSM for regexes (implementing only a subset of the POSIX regex syntax here for simplicity) as shown in Figure \ref{fig:rx-grammar-based}.

\begin{figure}[h!]
\vspace{-5px}
\begin{lstlisting}[deletekeywords={as}]
syntax $rx(R : RX) at R.t by static 
  P.generate ($grammar P proto_expr {|SHTML #\label{line:rx_parse_fn_start}#
    start <- ""
      EHTMLfn () => $proto_expr `SCSSR.EmptyECSS`SHTML
    start <- "(" start ")"
      EHTMLfn e => eSHTML
    token str_tok #\label{line:str_tok_start}#
      EHTMLRU.parse "SSTR[^(@$]+ESTR" (* cannot use $rx within its own def *)SHTML #\label{line:str_tok_end}#
    start <- str_tok
      EHTMLfn s => $proto_expr `SCSSR.Str %(ECSSstr_to_proto_lit sSCSS)ECSS`SHTML
    start <- start start
      EHTMLfn e1 e2 => $proto_expr `SCSSR.Seq (%ECSSe1SCSS, %ECSSe2SCSS)ECSS`SHTML
    start <- start "|" start 
      EHTMLfn e1 e2 => $proto_expr `SCSSR.Or (%ECSSe1SCSS, %ECSSe2SCSS)ECSS`SHTML
    start <- start "*"
      EHTMLfn e => $proto_expr `SCSSR.Star %ECSSe`SHTML

    using EHTMLspliced_uexpSHTML as spliced_uexp #\label{line:splicede_using}#
    start <- "${" spliced_uexp "}" #\label{line:splicing-start}#
      EHTMLfn e => eSHTML
    start <- "@{" spliced_uexp "}"
      EHTMLfn e => $proto_expr `SCSSR.Str %(ECSSeSCSS)ECSS`SHTML #\label{line:splicing-end}#
  EHTML|})
end #\label{line:rx_parse_fn_end}#
\end{lstlisting}
\vspace{-12px}
\caption{A grammar-based definition of \texttt{\$rx}.}
\vspace{-15px}
\label{fig:rx-grammar-based}
\end{figure}


\section{Library Management}
In the examples above, we explicitly qualified various definitions with the \li{static} keyword to make them available within static values. This captures the essential nature of the problem of static evaluation, but in practice, we would like to be able to use libraries within both static values and standard values as needed without duplicating code. This can be accomplished by the use of a language-external library and compilation manager. For example, a library and compilation manager for VerseML similar to SML/NJ's CM \cite{blume:smlnj-cm} could support a \li{static} qualifier on libraries, which would place the definitions exported by the imported library (without qualification) into the static phase of the library being defined:
\begin{lstlisting}[numbers=none,morekeywords={Library,is}]
Library 
  (* ... exports of library being defined ... *)
is 
  (* ... *)

  (* we do not need static qualifiers within parsegen.cm *)
  static parsegen.cm 
\end{lstlisting}
For the sake of generality and simplicity, we will leave the details of library and compilation management out of our formal developments (following the approach taken by the definition of Standard ML \cite{Tofte:89:TheDefinitionOfStandardML}.)
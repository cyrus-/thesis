% !TEX root = omar-thesis.tex

\section{Preliminaries}\label{sec:preliminaries}
This work is rooted in the tradition of full-scale functional languages with non-trivial type structure like Standard ML, OCaml and Haskell (as might have been obvious from Chapter \ref{chap:intro}.) Familiarity with basic concepts in these languages, e.g. variables, types, polymorphic and recursive functions, tuples, records, recursive datatypes and structural pattern matching, is assumed throughout this work. Readers who are not familiar with these concepts are encouraged to consult the early chapters of an introductory text like Harper's \emph{Programming in Standard ML} \cite{harper1997programming} (a working draft can be found online.) We discuss integrating TSMs into languages from other design traditions in Sec. \ref{sec:integration}.

Chapter \ref{chap:ptsms} and some of the motivating examples given below, consider questions of integration with an ML-style module system, so readers with experience in a language without such a module system (e.g. Haskell) are also advised to consult the relevant chapters in \emph{Programming in Standard ML} \cite{harper1997programming} as needed.

The formal systems that we will construct are defined within the metatheoretic framework of type theory. More specifically, we assume that abstract syntax trees (ASTs), abstract binding trees (ABTs, which enrich ASTs with the notions of binding and scope), substitution, renaming, alpha-equivalence, structural induction and rule induction are defined as described in Harper's \emph{Practical Foundations for Programming Languages, Second Edition} (\emph{PFPL}) \cite{pfpl}, except as otherwise stated. Familiarity with other formal accounts of type systems, e.g. Pierce's \emph{Types and Programming Languages} (\emph{TAPL}) \cite{tapl}, should also suffice. This document is organized so as to be readable even if the sections defining formal systems are skipped entirely (although much precision will, of course, be lost).


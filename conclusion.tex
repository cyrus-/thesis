% !TEX root = omar-thesis.tex
\chapter{Discussion \& Future Directions}\label{chap:conclusion}
\begin{quote}
\emph{Science is an endless search for truth. Any representation of reality we develop can be only partial. There is no finality, sometimes no single best representation. There is only deeper understanding, more revealing and enveloping representations.
}

-- Carl R. Woese \cite{woese}
\end{quote}

\section{Interesting Applications}
Most of the examples in Sec. \ref{sec:motivating-examples} can be expressed straightforwardly using the constructs introduced in the previous chapters. Here, let us highlight certain interesting examples and exceptions.

\subsection{Monadic Commands}\label{sec:application-monadic-commands}

\section{Summary}
\todo{Write summary}

\section{Future Directions}\label{sec:future-work}
We did not consider situations where a library clients wants to provide derived forms for defining types, signatures, modules or other declarations (though we have explored syntax for types in a recent short paper \cite{sac15}.) We also did not consider situations where a library client wants to generate an expression or a pattern based on the structure of a type (e.g. automatic generation of equality comparisons.) Finally, we do not consider situations that require modifications to the underlying type structure of a language (though ``reasonably programmable type structure'' is a rich avenue for future work.)

\subsection{TSM Packaging}\label{sec:tsm-packaging}

In the exposition thusfar, we have assumed that TSMs have delimited scope. However, ideally, we would like to be able to define TSMs within a module:
\begin{lstlisting}[numbers=none]
structure Rxlib = struct 
  type Rx = (* ... *)
  syntax $rx at Rx { (* ... *) }
  (* ... *)
end
\end{lstlisting}
However, this leads to an important question: how can we write down a signature for the module \li{Rxlib}? One approach would be to simply duplicate the full definition of the TSM in the signature, but this leads to inelegant code duplication and raises the difficult question of how the language should decide whether one TSM is a duplicate of another. For this reason, in VerseML, a signature can only refer to a previously defined TSM. So, for example, we can write down a signature for \li{Rxlib} after it has been defined:

\begin{lstlisting}[numbers=none]
signature RXLIB = sig 
  type Rx = (* ... *)
  syntax $rx = Rxlib.$rx
  (* ... *)
end
Rxlib : RXLIB (* check Rxlib against RXLIB after the fact *)
\end{lstlisting}

Alternatively, we can define the type \li{Rx} and the TSM \li{#\dolla#rx} before defining \li{Rxlib}:
\begin{lstlisting}[numbers=none]
local 
  type Rx = (* ... *)
  syntax $rx at Rx { (* ... *) }
in 
  structure Rxlib : 
  sig 
    type Rx = Rx
    syntax $rx = $rx
    (* ... *)
  end = struct 
    type Rx = Rx 
    syntax $rx = $rx
    (* ... *)
  end
end 
\end{lstlisting}

Another important question is: how does a TSM defined within a module at a type that is held abstract outside of that module operate? For example, consider the following:
\begin{lstlisting}[numbers=none]
local 
  type Rx = (* ... *)
  syntax $rx at Rx { (* ... *) }
in 
  structure Rxlib : 
  sig 
    type Rx (* held abstract *)
    syntax $rx = $rx
    (* ... *)
  end = struct 
    type Rx = Rx
    syntax $rx = $rx
    (* ... *)
  end
end 
\end{lstlisting}
If we apply \li{Rxlib.#\dolla#rx}, it may generate an expansion that uses the constructors of the \li{Rx} type. However, because the type is being held abstract, these constructors may not be visible at the application site. \todo{actually, this is why doing this is a bad idea. export TSMs only from units, not modules}

\subsection{TSLs}

\section{pTSLs By Example}
For example, a module \lstinline{P} can associate the TSM \lstinline{rx} defined in the previous section with the abstract type \lstinline{R.t} by qualifying the definition of the sealed module it is defined by as follows:
\begin{lstlisting}[numbers=none]
module R = mod {
  type t = (* ... *)
  (* ... *)
} :> RX with syntax rx
\end{lstlisting}
More generally, when sealing a module expression against a signature, the programmer can specify, for each abstract type that is generated, at most one previously defined TSMs. This TSM must take as its first parameter the module being sealed.

The following function has the same expansion as \lstinline{example_using_tsm} but, by using the TSL just defined, it is more concise. Notice the return type annotation, which is necessary to ensure that the TSL can be unambiguously determined:
\begin{lstlisting}[numbers=none]
fun example_using_tsl(name : string) : R.t => /SURL@EURLnameSURL: %EURLssn/
\end{lstlisting}

As another example, let us consider the standard list datatype. We can use TSLs to express derived list syntax, for both expressions and patterns:
\begin{lstlisting}[numbers=none]
datatype list('a) { Nil | Cons of 'a * list('a) } with syntax {
  static fn (body : Body) => 
    (* ... comma-delimited spliced exps ... *)
} with pattern syntax {
  static fn (body : Body) : Pat => 
    (* ... list pattern parser ... *)
}
\end{lstlisting}
Together with the TSL for regular expression patterns, this allows us to write lists like this:
\begin{lstlisting}[numbers=none]
let val x : list(R.t) = [/SURL\dEURL/SHTML, EHTML/SURL\d\dEURL/SHTML, EHTML/SURL\d\d\dEURL/]
\end{lstlisting}
From the client's perspective, it is essentially as if the language had built in derived syntax for lists and regular expression patterns directly.%However, we did not need to build in this syntax primitively.%The only constraint is that this syntax must be used in an analytic position, which we argue is actually better for code compren when encountering unfamiliar syntax.

\section{Parameterized Modules}
TSLs can be associated with abstract types that are generated by parameterized modules (i.e. generative functors in Standard ML) as well. For example, consider a trivially parameterized module that creates modules sealed against \lstinline{RX}:
\begin{lstlisting}[numbers=none]
module F() => mod {
  type t = (* ... *)
  (* ... *)
} :> RX with syntax rx 
\end{lstlisting}
Each application of \lstinline{F} generates a distinct abstract type. The semantics associates the appropriately parameterized TSM with each of these as they are generated:
\begin{lstlisting}[numbers=none]
module F1 = F() (* F1.t has TSL rx(F1) *)
module F2 = F() (* F2.t has TSL rx(F2) *)
\end{lstlisting}

As a more complex example, let us define two signatures, \lstinline{A} and \lstinline{B}, a TSM \texttt{\$G} and a parameterized module \lstinline{G : A -> B}:
\begin{lstlisting}[numbers=none,mathescape=|]
signature A = sig { type t; val x : t }
signature B = sig { type u; val y : u }
syntax $G(M : A)(G : B) at G.u { (* ... *) }
module G(M : A) => mod { 
  type u = M.t; val y = M.x } :> B with syntax $G(M)
\end{lstlisting}
Both \lstinline{G} and \texttt{\$G} take a parameter \lstinline{M : A}. We associate the partially applied TSM \texttt{\$G(M)} with the abstract type that \lstinline{G} generates. Again, this satisfies the requirement that one must be able to apply the TSM being associated with the abstract type to the module being sealed. 

Only fully abstract types can have TSLs associated with them. Within the definition of \lstinline{G}, type \lstinline{u} does not have a TSL available to it because it is synonymous to \lstinline{M.t}. More generally, TSL lookup respects type equality, so any synonyms of a type with a TSL will also have that TSL. We can see this in the following example, where the type \lstinline{u} has a different TSL associated with it inside and outside the definition of the module \lstinline{N}:
\begin{lstlisting}[numbers=none,mathescape=|]
module M : A = mod { type t = int; val x = 0 }
module G1 = G(M) (* G1.t has TSL $G(M), per above *)
module N = mod { 
  type u = G1.t (* u = G1.t in this scope, so u also has TSL $G(M) *)
  val y = /asdf/ (* we can use it to create a value of that type *) 
} :> B (* did not specify a TSL for N.u at the point where it is sealed, 
            so N.u has no TSL in the outer scope *)
val z : N.u = /asdf/ (* ERROR: no TSL for type N.u *)
\end{lstlisting}

\section{\texorpdfstring{$\miniVerseTSL$}{miniVerseTSL}}
A formal specification of TSLs in a language that supports only non-parametric datatypes is available in a paper published in ECOOP 2014 \cite{TSLs}. %We will add support for parameterized TSLs in the dissertation (see Sec. %\ref{sec:syntax-timeline}).

\subsection{TSMs and TSLs In Candidate Expansions}\label{sec:tsms-in-expansions}


Candidate expansions cannot themselves define or apply TSMs. This simplifies our metatheory, though it can be inconvenient at times for TSM providers. We discuss adding the ability to use TSMs within candidate expansions here.\todo{write this}

\subsection{Pattern Matching Over Values of Abstract Type}\label{sec:patterns-for-abstract-types}
ML does not presently support pattern matching over values of an abstract data type. However, there have been proposals for adding support for pattern matching over abstract data types defined by modules having a ``datatype-like'' shape, e.g. those that define a case analysis function like the one specified by \lstinline{RX}, %shown in Sec. \ref{sec:examples}. %We leave further discussion of such a facility and of parameterized TPSMs also as remaining work (see Sec. \ref{sec:syntax-timeline}). 


\subsection{Integration Into Other Languages}\label{sec:integration}
We conjecture that the constructs we describe could be integrated into dependently typed functional languages, e.g. Coq, but leave the technical developments necessary for doing so as future work.

Some of the constructs in Chapter \ref{chap:uetsms}, Chapter \ref{chap:ptsms} and Chapter \ref{chap:tsls} could also be adapted for use in imperative languages with non-trivial type structure, like Java. Similarly, some of the constructs we discuss could also be adapted into ``{dynamic languages}'' like Racket or Python, though the constructs in Chapter \ref{chap:tsls} are not relevant to such languages. 


\subsection{Mechanically Verifying TSM Definitions}\label{sec:verifying-tsms}
Finally, VerseML is not designed for advanced theorem proving tasks where languages like Coq, Agda or Idris might be used today. That said, we conjecture that the primitives we describe could be integrated into languages like Gallina (the ``external language'' of the Coq proof assistant  \cite{Coq:manual}) with  modifications, but do not plan to pursue this line of research here.

In such a setting, you could verify TSM definitions \todo{finish writing this}
\subsection{Improved Error Reporting}\label{sec:error-handling}
\subsection{Controlled Binding}\label{sec:controlled-binding}
\subsection{Type-Aware Splicing}\label{sec:type-aware-splicing}
\subsection{Integration With Code Editors}\label{sec:interaction-with-tools}
\subsection{Resugaring}\label{sec:resugaring}
\todo{Cite recent work at PLDI (?) and ICFP from Brown}
\subsection{Non-Textual Display Forms}\label{sec:non-textual-display-forms}
\todo{Talk about active code completion work and future ideas}

\newpage
\section*{\LaTeX~Source Code and Updates}
\addcontentsline{toc}{chapter}{\LaTeX~Source Code and Updates}
\noindent
The \LaTeX~sources for this document can be found at the following URL:
\begin{center}
\url{https://github.com/cyrus-/thesis}
\end{center}
The latest version of this document can be downloaded from the following URL:
\begin{center}
\url{https://github.com/cyrus-/thesis/raw/master/omar-thesis.pdf}
\end{center}
Any errors or omissions can be reported to the author by email at the following address:
\begin{center}
\url{comar@cs.cmu.edu}
\end{center}
The author will also review and accept pull requests on GitHub.
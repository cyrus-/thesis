% !TEX root = omar-thesis.tex

\chapter{Parameterized TSMs (pTSMs)}\label{chap:ptsms}
In the preceding chapters, we introduced unparameterized TSMs (uTSMs). uTSMs are defined at a single type, like \li{Rx}, and the expansions that they generate have access to bindings at the application site only via spliced subterms. In this chapter, we introduce \emph{parameterized TSMs} (pTSMs) -- TSMs parameterized by types and modules. pTSMs can be defined over a parameterized family of types, and can access their parameters within the expansions that they generate. 

This chapter is organized much like the preceding chapters. We begin in Sec. \ref{sec:parameterized-tsms-by-example} by introducing parameterized TSMs by example in VerseML. In particular, we discuss type parameters in Sec. \ref{sec:type-parameters} and module parameters in Sec. \ref{sec:module-parameters}. We then formalize parameterized TSMs by defining a reduced calculus, $\miniVerseParam$, in Sec. \ref{sec:miniVerseP}.
\section{Parameterized TSMs By Example}\label{sec:parameterized-tsms-by-example}

\subsection{Type Parameters}\label{sec:type-parameters}
VerseML, like many ML dialects, provides support for defining \emph{type constructors}, which express type-parameterized families of types. The canonical example is the type constructor \li{list}, which constructs list types given one type parameter, the \emph{element type}. 
In VerseML, \li{list} is defined as follows.
\begin{lstlisting}[numbers=none]
type list('a) = Nil | Cons of 'a * list('a)
\end{lstlisting}

For any type \li{T}, the type of lists containing elements of type \li{T} can be constructed by applying \li{list} to \li{T}, written \li{list(T)}.\footnote{As with function application, the parentheses are optional (though for type constructor application, it is typical to include them). In many other ML dialects, type parameters are given in prefix form, e.g. in Standard ML, one writes \li{int list} rather than \li{list(int)}.} In other words, type constructors can be understood as total functions at the level of \emph{constructor expressions}. 

\emph{Kinds} classify constructor expressions, much like types classify expressions. Types are constructor expressions of kind \li{T}, and type constructors are constructor expressions of arrow kind. Here, \li{list} takes a single type parameter, so it has arrow kind \li{T -> T}.

As discussed in Sec. \ref{sec:syntax-examples-containers}, full-scale ML dialects commonly define derived syntactic forms that decrease the syntactic cost of introducing and pattern matching over values of list type. VerseML, in contrast, does not build in such derived list forms. 

In lieu of derived forms for introducing lists, we define the following \emph{parameterized expression TSM} (peTSM):
\begin{lstlisting}
syntax $list('a) at list('a) {
  static fn(body : Body) : ParseResult(CEExp) => (* ... *)
}
\end{lstlisting}
Line 1 names the peTSM \li{#\dolla#list} and specifies a single type parameter, \li{'a} (implicitly of kind \li{T}). This type parameter appears in the type annotation, which specifies that \li{#\dolla#list}, when applied to a type \li{'a} and a generalized literal form, will only generate expansions of type \li{list('a)}. For example, we can apply \li{#\dolla#list} to the type \li{int} and generalized literal forms delimited by square brackets as follows.
\begin{lstlisting}[numbers=none]
val y = $list(int) [3SURL, EURL4SURL, EURL5]
val x = $list(int) [1SURL, EURL2SURL :: EURLy]
\end{lstlisting}

Line 2 of the definition of \li{#\dolla#list} defines its parse function. Parse functions operate as described in Chapter \ref{chap:uetsms} to generate encodings of candidate expansions, which are subsequently validated to generate the final expansions of expressions of peTSM application form, like those in the example above. For \li{#\dolla#list}, the parse function (whose body is elided above for concision) breaks the literal body up into  spliced subexpressions -- those separated by commas become individual elements at the head of the list being generated, and, optionally, a trailing spliced subexpression prefixed by two colons (\li{SURL::EURL}) becomes the tail of the list being generated (the tail is \li{Nil} otherwise). The final expansion of the example above, if written textually, is:
\begin{lstlisting}[numbers=none]
val y : list(int) = Cons(3, Cons(4, Cons(5, Nil)))
val x : list(int) = Cons(1, Cons(2, y))
\end{lstlisting}
% differing only in that any type parameter that the peTSM specifies can appear free in the generated expansion.

Similarly, in lieu of derived list pattern forms, we define the following \emph{parameterized pattern TSM} (ppTSM):
\begin{lstlisting}[numbers=none]
syntax $list('a) at list('a) for patterns {
  static fn(body : Body) : ParseResult(CEPat) => (* ... *)
}
\end{lstlisting}
Again, Line 1 names the ppTSM \li{#\dolla#list} and specifies a single type parameter, \li{'a}. This type parameter appears in the type annotation, which specifies that \li{#\dolla#list}, when apply to a type \li{'a} and a generalized literal form, will only generate patterns that match values of type \li{list('a)}. 

For example, we can apply the ppTSM \li{#\dolla#list} and the \li{#\dolla#list} to define the polymorphic map function as follows.
\begin{lstlisting}[numbers=none]
fun map (f : 'a -> 'b) (x : list('a)) => match x { 
  $list('a) [] => $list('b) []
| $list('a) [hdSURL :: EURLtl] => $list('b) [f hdSURL :: EURLmap f tl]
}
\end{lstlisting}
The expansion of this function definition, written textually, is:
\begin{lstlisting}[numbers=none]
fun map (f : 'a -> 'b) (x : list('a)) : 'b list => match x { 
  Nil => Nil
| Cons(hd, tl) => Cons(f hd, map f tl)
}
\end{lstlisting}
This is somewhat unsatisfying, however, because the expansion is more concise than the unexpanded definition of \li{map}. To further reduce syntactic cost, we can designate \li{#\dolla#list} as the implicit TSM for both expressions and patterns at all types \li{'a list} around our definition of \li{map} as follows.
\begin{lstlisting}[numbers=none]
implicit syntax $list('a) in
  fun map (f : 'a -> 'b) (x : 'a list) : 'b list => match x {
    [] => []
  | [hdSURL :: EURLtl] => [f hdSURL :: EURLmap f tl]
  }
end
\end{lstlisting}
By designating an implicit TSM, we no longer need to explicitly apply \li{#\dolla#list} within expressions in analytic position or patterns.

% When designating an implicit TSM, we assume that free type variables in the type annotation, e.g. here \li{'a}, range over all types. We can make this more explicit by specifying a type parameter explicitly as follows:
% \begin{lstlisting}[numbers=none]
% implicit syntax('a) $list('a) at list('a) in
% 	(* ... *)
% end
% \end{lstlisting}
% All type parameters must appear in the type annotation.
\subsection{Module Parameters}\label{sec:module-parameters}
VerseML also provides a module language based on the Standard ML module language \cite{MacQueen:1984:MSM:800055.802036}. The module language consists of \emph{module expressions} classified by \emph{signatures}. %Signatures specify type components, which may be opaque or transparent, value components, and module components.h

%In Sec. \ref{sec:motivating-examples}, we gave several examples of signatures and discussed how one might introduce derived forms that  across a module-parameterized family of types.

The canonical example is the signature for working with persistent queues.
\begin{lstlisting}[numbers=none]
signature QUEUE = sig
  type queue('a)
  val empty  : queue('a)
  val insert : 'a * queue('a) -> queue('a)
  val remove : queue('a) -> option('a * queue('a))
end 
\end{lstlisting}
Structures that match this signature must define a type constructor \li{queue} of kind \li{T -> T} and three values -- \li{empty} introduces the empty queue, \li{insert} inserts a value onto the back of a queue, and \li{remove} removes the element at the front of the queue and returns it and the remaining queue, or \li{None} if the queue is empty.%one for inserting an item into a queue, and one for removing a value from a queue.

There are many possible structures that implement this signature. For example, we can define a structure \li{ListQueue} that represents queues internally as lists, where the head of the list is the back of the queue. With this representation, \li{insert} is a constant time operation, but \li{remove} is a linear time operation. Alternatively, we might define a structure \li{TwoListQueue} that represents queues internally as a pair of lists, maintaining the invariant that one is the reverse of the other, so that both \li{insert} and \li{remove} are constant time operations (see \cite{harper1997programming} for the details of this and other possibilities). 

Regardless of the implementation that the client chooses, we would like for the client to be able to introduce queues more naturally and at lower syntactic cost than is possible by directly applying the functions specified by the signature above. In VerseML, we can give clients of structures matching the signature \li{QUEUE} this ability by defining the following parameterized expression TSM:
\begin{lstlisting}[numbers=none]
syntax $queue(Q : QUEUE)('a) at Q.queue('a) {
	static fn(body : Body) : ParseResult(CEExp) => (* ... *)
}
\end{lstlisting}
This peTSM specifies one module parameter, \li{Q}, which must match the signature \li{QUEUE}, and one type parameter, \li{'a} (implicitly of kind \li{T}). These appear in the type annotation, which specifies that expansions that arise from applying \li{#\dolla#queue} to a module \li{Q : QUEUE} and a type \li{'a} will be of type \li{Q.queue('a)}. For example:
\begin{lstlisting}
val q = $queue TwoListQueue int [SURL> EURL1SURL, EURL2SURL, EURL3]
val q' = $queue TwoListQueue int [qSURL > EURL4SURL, EURL5]
\end{lstlisting}
On Line 1, the initial angle bracket (\li{SURL>EURL}) indicates that the items are inserted in left-to-right order. The items in the queue are given as spliced subexpressions separated by commas. Line 2 inserts two additional items onto the back of the queue \li{q}. The expansion of this example, written textually, is:
\begin{lstlisting}
val q : TwoListQueue.queue(int) = 
	TwoListQueue.insert(1, 
		TwoListQueue.insert(2, 
			TwoListQueue.insert(3, 
				TwoListQueue.empty)))
val q' : TwoListQueue.queue(int) = 
  TwoListQueue.insert(4, TwoListQueue.insert(5, q))
\end{lstlisting}
Notice that the expansion can refer to the module parameter \li{TwoListQueue}.

We can further reduce syntactic cost by defining a synonym for the partial application of \li{#\dolla#queue} to the module parameter \li{TwoListQueue}:
\begin{lstlisting}[numbers=none]
syntax $tlq = $queue TwoListQueue
val q = $tlq int [SURL> EURL1SURL, EURL2SURL, EURL3]
\end{lstlisting}
We can further define a synonym for the partial application of \li{#\dolla#tlq} to a type parameter:
\begin{lstlisting}[numbers=none]
syntax $tlqi = $tlq int (* = $queue TwoListQueue int *)
val q' = $tlqi [qSURL > EURL4SURL, EURL5]
\end{lstlisting}

Another way to reduce syntactic cost is by designating \li{#\dolla#queue Q 'a} the implicit TSM at all types of the form \li{Q.queue('a)} where \li{Q : QUEUE}. This is written as follows:
\begin{lstlisting}[numbers=none]
implicit syntax (Q : QUEUE) ('a) => $queue Q 'a in
  val q : TwoListQueue.queue(int) = [SURL> EURL1SURL, EURL2SURL, EURL3]
  val q' : TwoListQueue.queue(int) = [qSURL > EURL4SURL, EURL5]
end
\end{lstlisting}
This designation is particularly useful for clients who need to construct a queue as an argument to a function. For example, consider a function 
\begin{lstlisting}[numbers=none]
enqueue_jobs : Q.queue(Job) -> Ticket
\end{lstlisting}
for some module \li{Q : QUEUE} and types \li{Job} and \li{Ticket}. We can enqueue a sequence of jobs \li{j1} through \li{j4} under the TSM designation above as follows:
\begin{lstlisting}[numbers=none]
enqueue_jobs [SURL> EURLj1SURL, EURLj2SURL, EURLj3SURL, EURLj4]
\end{lstlisting}


\begin{figure}[p] 
$\begin{array}{lrlllll}
\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{Kind} & \kappa & ::= & \akdarr{\kappa}{u}{\kappa} & \kdarr{u}{\kappa}{\kappa} & \text{dependent function}\\
&&& \akunit & \kunit & \text{nullary product}\\
&&& \akdbprod{\kappa}{u}{\kappa} & \kdbprod{u}{\kappa}{\kappa} & \text{dependent product}\\
%&&& \akdprodstd & \kdprodstd & \text{labeled dependent product}\\
&&& \akty & \kty & \text{types}\\
&&& \aksing{\tau} & \ksing{\tau} & \text{singleton}\\
\mathsf{Con} & c, \tau & ::= & u & u & \text{variable}\\
&&& t & t & \text{variable}\\
&&& \acabs{u}{c} & \cabs{u}{c} & \text{abstraction}\\
&&& \acapp{c}{c} & \capp{c}{c} & \text{application}\\
&&& \actriv & \ctriv & \text{trivial}\\
&&& \acpair{c}{c} & \cpair{c}{c} & \text{pair}\\
&&& \acprl{c} & \cprl{c} & \text{left projection}\\
&&& \acprr{c} & \cprr{c} & \text{right projection}\\
%&&& \adtplX & \dtplX & \text{labeled dependent tuple}\\
%&&& \adprj{\ell}{c} & \prj{c}{\ell} & \text{projection}\\
&&& \aparr{\tau}{\tau} & \parr{\tau}{\tau} & \text{partial function}\\
&&& \aallu{\kappa}{u}{\tau} & \forallu{u}{\kappa}{\tau} & \text{polymorphic}\\
&&& \arec{t}{\tau} & \rect{t}{\tau} & \text{recursive}\\
&&& \aprod{\labelset}{\mapschema{\tau}{i}{\labelset}} & \prodt{\mapschema{\tau}{i}{\labelset}} & \text{labeled product}\\
&&& \asum{\labelset}{\mapschema{\tau}{i}{\labelset}} & \sumt{\mapschema{\tau}{i}{\labelset}} & \text{labeled sum}\\
&&& \amcon{M} & \mcon{M} & \text{constructor part}
\end{array}$
\caption[Syntax of kinds and constructors in $\miniVerseParam$]{Syntax of kinds and constructors in $\miniVerseParam$. By convention, we choose the metavariable $\tau$ for constructors that, in well-formed terms, must necessarily be of kind $\kty$, and the metavariable $c$ otherwise. Similarly, we use constructor variables $t$ to stand for constructors of kind $\kty$, and constructor variables $u$ otherwise. Kinds and constructors are identified up to $\alpha$-equivalence.}
\label{fig:P-kinds-constructors}
\end{figure}

\begin{figure}[p] 
$\begin{array}{lllllll}
\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{Exp} & e & ::= & x & x & \text{variable}\\
&&& \aelam{\tau}{x}{e} & \lam{x}{\tau}{e} & \text{abstraction}\\
&&& \aeap{e}{e} & \ap{e}{e} & \text{application}\\
&&& \aeclam{\kappa}{u}{e} & \clam{u}{\kappa}{e} & \text{constructor abstraction}\\
&&& \aecap{e}{\kappa} & \cAp{e}{\kappa} & \text{constructor application}\\
&&& \aefold{t}{\tau}{e} & \fold{e} & \text{fold}\\
&&& \aeunfold{e} & \unfold{e} & \text{unfold}\\
&&& \aetpl{\labelset}{\mapschema{e}{i}{\labelset}} & \tpl{\mapschema{e}{i}{\labelset}} & \text{labeled tuple}\\
&&& \aepr{\ell}{e} & \prj{e}{\ell} & \text{projection}\\
&&& \aein{\labelset}{\ell}{\mapschema{\tau}{i}{\labelset}}{e} & \inj{\ell}{e} & \text{injection}\\
&&& \aematchwith{n}{\tau}{e}{\seqschemaX{r}} & \matchwith{e}{\seqschemaX{r}} & \text{match}\\
&&& \amval{M} & \mval{M} & \text{value part}\\
\mathsf{Rule} & r & ::= & \aematchrule{p}{e} & \matchrule{p}{e} & \text{rule}\\
\mathsf{Pat} & p & ::= & x & x & \text{variable pattern}\\
&&& \aewildp & \wildp & \text{wildcard pattern}\\
&&& \aefoldp{p} & \foldp{p} & \text{fold pattern}\\
&&& \aetplp{\labelset}{\mapschema{p}{i}{\labelset}} & \tplp{\mapschema{p}{i}{\labelset}} & \text{labeled tuple pattern}\\
&&& \aeinjp{\ell}{p} & \injp{\ell}{p} & \text{injection pattern}
\end{array}$
\caption[Syntax of expanded expressions, rules and patterns in $\miniVerseParam$]{Syntax of expanded expressions, rules and patterns (collectively, expanded terms) in $\miniVerseParam$. Expanded terms are identified up to $\alpha$-equivalence.}
\label{fig:P-expanded-terms}
\end{figure}

\begin{figure}[p] 
$\begin{array}{lllllll}
\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{Sig} & \sigma & ::= & \asignature{\kappa}{u}{\tau} & \signature{u}{\kappa}{\tau} & \text{signature}\\
\mathsf{Mod} & M & ::= & X & X & \text{variable}\\
&&& \astruct{c}{e} & \struct{c}{e} & \text{structure}\\
&&& \aseal{\sigma}{M} & \seal{M}{\sigma} & \text{seal}\\
&&& \amlet{\sigma}{M}{X}{M} & \mlet{X}{M}{M}{\sigma} & \text{definition}
\end{array}$
\caption[Syntax of module expressions and signatures in $\miniVerseParam$]{Syntax of module expressions and signatures in $\miniVerseParam$. Module expressions and signatures are identified up to $\alpha$-equivalence.}
\label{fig:P-modules-signatures}
\end{figure}

\section{\texorpdfstring{$\miniVerseParam$}{miniVerseForall}}\label{sec:miniVerseP}
\subsection{Syntax of the Inner Language}


\subsubsection{Syntax of the Inner Core Language}
We adopt the metatheoretic conventions established for our definitions of $\miniVerseUE$ in Sec. \ref{sec:miniVerseU} and $\miniVersePat$ in Sec. \ref{sec:miniVerseUP} without restating them. 

Kinds and constructors in Figure \ref{fig:P-kinds-constructors}.

Expanded expressions, rules and patterns in Figure \ref{fig:P-expanded-terms}.

\subsubsection{Syntax of the Inner Module Language}
Module expressions and signatures in Figure \ref{fig:P-modules-signatures}.

\subsection{Statics of the Inner Language}
The \emph{statics of the inner language} is defined by a collection of judgements that we organize into three groups.

The first group of judgements, which we refer to as the \emph{statics of the inner constructor language}, define the statics of expanded kinds and constructors.

\vspace{10px}
$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\iskindX{\kappa} & \text{$\kappa$ is a well-formed kind}\\
\kequalX{\kappa}{\kappa'} & \text{$\kappa$ and $\kappa'$ are equivalent}\\
\ksubX{\kappa}{\kappa'} & \text{$\kappa$ is a subkind of $\kappa'$}\\
\haskindX{c}{\kappa} & \text{$c$ has kind $\kappa$}\\
\cequalX{c}{c'}{\kappa} & \text{$c$ and $c'$ are equivalent as constructors of kind $\kappa$}
\end{array}$
\vspace{10px}

The second group of judgements, which we refer to as the \emph{statics of the inner core language}, define the statics of types, expanded expressions, rules and patterns.

\vspace{10px}
$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\istypeP{\Omega}{\tau} & \text{$\tau$ is a well-formed type}\\
\tequalPX{\tau}{\tau'} & \text{$\tau$ and $\tau'$ are equivalent types}\\
\issubtypePX{\tau}{\tau'} & \text{$\tau$ is a subtype of $\tau'$}\\
\hastypeP{\Omega}{e}{\tau} & \text{$e$ is assigned type $\tau$}\\
\ruleTypeP{\Omega}{r}{\tau}{\tau'} & \text{$r$ takes values of type $\tau$ to values of type $\tau'$}\\
\patTypeP{\Omega'}{p}{\tau} & \text{$p$ matches values of type $\tau$ and generates hypotheses $\Omega'$} 
\end{array}$
\vspace{10px}

The third group of judgements, which we refer to as the \emph{statics of the inner module language}, define the statics of expanded signatures and module expressions.

\vspace{10px}
$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\issigX{\sigma} & \text{$\sigma$ is a well-formed signature }\\
\sigequalX{\sigma}{\sigma'} & \text{$\sigma$ and $\sigma'$ are definitionally equal}\\
\sigsubX{\sigma}{\sigma'} & \text{$\sigma$ is a sub-signature of $\sigma'$}\\
\hassigX{M}{\sigma} & \text{$M$ has signature $\sigma$}\\
\ismvalX{M} & \text{$M$ is a module value}
\end{array}$
\vspace{10px}

A \emph{unified inner context}, $\Omega$, is a finite function that maps
\begin{itemize}
\item each expression variable $x \in \domof{\Omega}$ to the hypothesis $\Ghyp{x}{\tau}$ for some $\tau$;
\item each constructor variable $u \in \domof{\Omega}$ to the hypothesis $u :: \kappa$ for some $\kappa$; and
\item each module variable $X \in \domof{\Omega}$ to the hypothesis $X :: \sigma$ for some $\sigma$.
\end{itemize}
We write
\begin{itemize}
\item $\Omega, x : \tau$ when $x \notin \domof{\Omega}$ and $\haskindX{\tau}{\akty}$ for the extension of $\Omega$ with a mapping from $x$ to $x : \tau$
\item $\Omega, u :: \kappa$ when $u \notin \domof{\Omega}$ and $\iskindX{\kappa}$ for the extension of $\Omega$ with a mapping from $u$ to $u :: \kappa$
\item $\Omega, X : \sigma$ when $X \notin \domof{\Omega}$ and $\issigX{\sigma}$ for the extension of $\Omega$ with a mapping from $X$ to $X : \sigma$.
\end{itemize}
A well-formed unified inner context is one that can be constructed by some sequence of such extensions, start from the empty context, $\emptyset$.

%A well-formed unified inner context is one where there are no cycles in the dependency graph between the hypotheses (constructed in the obvious manner) and for each hypothesis, the constructor, kinds or signature involved is well-formed relative to the unified inner context.

\subsubsection{Kinds and Constructors}
Kind formation \todo{describe these}
\begin{subequations}\label{rules:iskind}
\begin{equation}\label{rule:iskind-darr}
\inferrule{
	\iskindX{\kappa_1}\\
	\iskind{\Omega, u :: \kappa_1}{\kappa_2}
}{
	\iskindX{\akdarr{\kappa_1}{u}{\kappa_2}}
}
\end{equation}
\begin{equation}\label{rule:iskind-unit}
\inferrule{ }{
	\iskindX{\akunit}
}
\end{equation}
\begin{equation}\label{rule:iskind-dprod}
\inferrule{
	\iskindX{\kappa_1}\\
	\iskind{\Omega, u :: \kappa_1}{\kappa_2}
}{
	\iskindX{\akdbprod{\kappa_1}{u}{\kappa_2}}
}
\end{equation}
\begin{equation}\label{rule:iskind-ty}
\inferrule{ }{
	\iskindX{\akty}
}
\end{equation}
\begin{equation}\label{rule:iskind-sing}
\inferrule{
	\haskindX{\tau}{\akty}
}{
	\iskindX{\aksing{\tau}}
}
\end{equation}
\end{subequations}

Kind definitional equality \todo{describe these}
\begin{subequations}\label{rules:kequal}
\begin{equation}\label{rule:kequal-refl}
\inferrule{
	\iskindX{\kappa}
}{
	\kequalX{\kappa}{\kappa}
}
\end{equation}
\begin{equation}\label{rule:kequal-sym}
\inferrule{
	\kequalX{\kappa}{\kappa'}
}{
	\kequalX{\kappa'}{\kappa}
}
\end{equation}
\begin{equation}\label{rule:kequal-trans}
\inferrule{
	\kequalX{\kappa}{\kappa'}\\
	\kequalX{\kappa'}{\kappa''}
}{
	\kequalX{\kappa}{\kappa''}
}
\end{equation}
\begin{equation}\label{rule:kequal-darr}
\inferrule{
	\kequalX{\kappa_1}{\kappa_1'}\\
	\kequal{\Omega, u :: \kappa_1}{\kappa_2}{\kappa_2'}
}{
	\kequalX{\akdarr{\kappa_1}{u}{\kappa_2}}{\akdarr{\kappa_1'}{u}{\kappa_2'}}
}
\end{equation}
\begin{equation}\label{rule:kequal-dprod}
\inferrule{
	\kequalX{\kappa_1}{\kappa'_1}\\
	\kequal{\Omega, u :: \kappa_1}{\kappa_2}{\kappa'_2}
}{
	\kequalX{\akdbprod{\kappa_1}{u}{\kappa_2}}{\akdbprod{\kappa'_1}{u}{\kappa'_2}}	
}
\end{equation}
\begin{equation}\label{rule:kequal-sing}
\inferrule{
	\cequalX{c}{c'}{\akty}
}{
	\kequalX{\aksing{c}}{\aksing{c'}}
}
\end{equation}
\end{subequations}
Subkinding \todo{describe these}
\begin{subequations}\label{rules:ksub}
\begin{equation}\label{rule:ksub-equal}
\inferrule{
	\kequalX{\kappa}{\kappa'}
}{
	\ksubX{\kappa}{\kappa'}
}
\end{equation}
\begin{equation}\label{rule:ksub-trans}
\inferrule{
	\ksubX{\kappa}{\kappa'}\\
	\ksubX{\kappa'}{\kappa''}
}{
	\ksubX{\kappa}{\kappa''}
}
\end{equation}
\begin{equation}\label{rule:ksub-darr}
\inferrule{
	\ksubX{\kappa'_1}{\kappa_1}\\
	\ksub{\Omega, u :: \kappa'_1}{\kappa_2}{\kappa'_2}	
}{
	\ksubX{\akdarr{\kappa_1}{u}{\kappa_2}}{\akdarr{\kappa'_1}{u}{\kappa'_2}}
}
\end{equation}
\begin{equation}\label{rule:ksub-dprod}
\inferrule{
	\ksubX{\kappa_1}{\kappa'_1}\\
	\ksub{\Omega, u :: \kappa_1}{\kappa_2}{\kappa'_2}
}{
	\ksubX{\akdbprod{\kappa_1}{u}{\kappa_2}}{\akdbprod{\kappa'_1}{u}{\kappa'_2}}
}
\end{equation}
\begin{equation}\label{rule:ksub-sing}
\inferrule{
	\haskindX{\tau}{\akty}
}{
	\ksubX{\aksing{\tau}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:ksub-sing-2}
\inferrule{
	\issubtypePX{\tau}{\tau'}
}{
	\ksubX{\aksing{\tau}}{\aksing{\tau'}}{\akty}
}
\end{equation}
\end{subequations}
Kinding \todo{describe these}
\begin{subequations}\label{rules:haskind}
\begin{equation}\label{rule:haskind-subsume}
\inferrule{
	\haskindX{c}{\kappa_1}\\
	\ksubX{\kappa_1}{\kappa_2}
}{
	\haskindX{c}{\kappa_2}
}
\end{equation}
\begin{equation}\label{rule:haskind-var}
\inferrule{ }{\haskind{\Omega, u :: \kappa}{u}{\kappa}}
\end{equation}
\begin{equation}\label{rule:haskind-abs}
\inferrule{
	\haskind{\Omega, u :: \kappa_1}{c_2}{\kappa_2}
}{
	\haskindX{\acabs{u}{c_2}}{\akdarr{\kappa_1}{u}{\kappa_2}}
}
\end{equation}
\begin{equation}\label{rule:haskind-app}
\inferrule{
	\haskindX{c_1}{\akdarr{\kappa_2}{u}{\kappa}}\\
	\haskindX{c_2}{\kappa_2}
}{
	\haskindX{\acapp{c_1}{c_2}}{[c_1/u]\kappa}
}
\end{equation}
\begin{equation}\label{rule:haskind-unit}
\inferrule{ }{
	\haskindX{\actriv}{\akunit}
}
\end{equation}
\begin{equation}\label{rule:haskind-pair}
\inferrule{
	\haskindX{c_1}{\kappa_1}\\
	\haskindX{c_2}{[c_1/u]\kappa_2}
}{
	\haskindX{\acpair{c_1}{c_2}}{\akdbprod{\kappa_1}{u}{\kappa_2}}
}
\end{equation}
\begin{equation}\label{rule:haskind-prl}
\inferrule{
	\haskindX{c}{\akdbprod{\kappa_1}{u}{\kappa_2}}
}{
	\haskindX{\acprl{c}}{\kappa_1}
}
\end{equation}
\begin{equation}\label{rule:haskind-prr}
\inferrule{
	\haskindX{c}{\akdbprod{\kappa_1}{u}{\kappa_2}}
}{
	\haskindX{\acprr{c}}{[\acprl{c}/u]\kappa_2}
}
\end{equation}
\begin{equation}\label{rule:haskind-parr}
\inferrule{
	\haskindX{\tau_1}{\akty}\\
	\haskindX{\tau_2}{\akty}
}{
	\haskindX{\aparr{\tau_1}{\tau_2}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:haskind-all}
\inferrule{
	\iskindX{\kappa}\\
	\haskind{\Omega, u :: \kappa}{\tau}{\akty}
}{
	\haskindX{\aallu{\kappa}{u}{\tau}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:haskind-rec}
\inferrule{
	\haskind{\Omega, t :: \akty}{\tau}{\akty}
}{
	\haskindX{\arec{t}{\tau}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:haskind-prod}
\inferrule{
	\{\haskindX{\tau_i}{\akty}\}_{1 \leq i \leq n}
}{
	\haskindX{\aprod{\labelset}{\mapschema{\tau}{i}{\labelset}}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:haskind-sum}
\inferrule{
	\{\haskindX{\tau_i}{\akty}\}_{1 \leq i \leq n}
}{
	\haskindX{\asum{\labelset}{\mapschema{\tau}{i}{\labelset}}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:haskind-sing}
\inferrule{
	\haskindX{c}{\akty}
}{
	\haskindX{c}{\aksing{c}}
}
\end{equation}
\begin{equation}\label{rule:haskind-stat}
\inferrule{
	\ismvalX{M}\\
	\hassigX{M}{\asignature{\kappa}{u}{\tau}}
}{
	\haskindX{\amcon{M}}{\kappa}
}
\end{equation}
\end{subequations}

Constructor equality\todo{describe this}
\begin{subequations}\label{rules:cequal}
\begin{equation}\label{rule:cequal-refl}
\inferrule{
	\haskindX{c}{\kappa}
}{
	\cequalX{c}{c}{\kappa}
}
\end{equation}
\begin{equation}\label{rule:cequal-sym}
\inferrule{
	\cequalX{c}{c'}{\kappa}
}{
	\cequalX{c'}{c}{\kappa}
}
\end{equation}
\begin{equation}\label{rule:cequal-trans}
\inferrule{
	\cequalX{c}{c'}{\kappa}\\
	\cequalX{c'}{c''}{\kappa}
}{
	\cequalX{c}{c''}{\kappa}
}
\end{equation}
\begin{equation}\label{rule:cequal-lam}
\inferrule{
	\cequal{\Omega, u :: \kappa_1}{c}{c'}{\kappa_2}
}{
	\cequalX{\acabs{u}{c}}{\acabs{u}{c'}}{\akdarr{\kappa_1}{u}{\kappa_2}}
}
\end{equation}
\begin{equation}\label{rule:cequal-app-1}
\inferrule{
	\cequalX{c_1}{c_1'}{\akdarr{\kappa_2}{u}{\kappa}}\\
	\cequalX{c_2}{c_2'}{\kappa_2}
}{
	\cequalX{\acapp{c_1}{c_2}}{\acapp{c'_1}{c'_2}}{\kappa}
}
\end{equation}
\begin{equation}\label{rule:cequal-app-2}
\inferrule{
	\haskindX{\acabs{u}{c}}{\akdarr{\kappa_2}{u}{\kappa}}\\
	\haskindX{c_2}{\kappa_2}
}{
	\cequalX{\acapp{\acabs{u}{c}}{c_2}}{[c_2/u]c}{[c_2/u]\kappa}
}
\end{equation}
\begin{equation}\label{rule:cequal-pair}
\inferrule{
	\cequalX{c_1}{c'_1}{\kappa_1}\\
	\cequalX{c_2}{c'_2}{[c_1/u]\kappa_2}
}{
	\cequalX{\acpair{c_1}{c_2}}{\acpair{c'_1}{c'_2}}{\akdbprod{\kappa_1}{u}{\kappa_2}}
}
\end{equation}
\begin{equation}\label{rule:cequal-prl-1}
\inferrule{
	\cequalX{c}{c'}{\akdbprod{\kappa_1}{u}{\kappa_2}}
}{
	\cequalX{\acprl{c}}{\acprl{c'}}{\kappa_1}
}
\end{equation}
\begin{equation}\label{rule:cequal-prl-2}
\inferrule{
	\haskindX{c_1}{\kappa_1}\\
	\haskindX{c_2}{\kappa_2}
}{
	\cequalX{\acprl{\acpair{c_1}{c_2}}}{c_1}{\kappa_1}
}
\end{equation}
\begin{equation}\label{rule:cequal-prr-1}
\inferrule{
	\cequalX{c}{c'}{\akdbprod{\kappa_1}{u}{\kappa_2}}
}{
	\cequalX{\acprr{c}}{\acprr{c'}}{[\acprl{c}/u]\kappa_2}
}
\end{equation}
\begin{equation}\label{rule:cequal-prr-2}
\inferrule{
	\haskindX{c_1}{\kappa_1}\\
	\haskindX{c_2}{\kappa_2}
}{
	\cequalX{\acprr{\acpair{c_1}{c_2}}}{c_2}{\kappa_2}
}
\end{equation}
\begin{equation}\label{rule:cequal-parr}
\inferrule{
	\cequalX{\tau_1}{\tau'_1}{\akty}\\
	\cequalX{\tau_2}{\tau'_2}{\akty}
}{
	\cequalX{\aparr{\tau_1}{\tau_2}}{\aparr{\tau'_1}{\tau'_2}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cequal-all}
\inferrule{
	\kequalX{\kappa}{\kappa'}\\
	\cequal{\Omega, u :: \kappa}{\tau}{\tau'}{\akty}
}{
	\cequalX{\aallu{\kappa}{u}{\tau}}{\aallu{\kappa'}{u}{\tau'}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cequal-rec}
\inferrule{
	\cequal{\Omega, t :: \akty}{\tau}{\tau'}{\akty}
}{
	\cequalX{\arec{t}{\tau}}{\arec{t}{\tau'}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cequal-prod}
\inferrule{
	\{\cequalX{\tau_i}{\tau'_i}{\akty}\}_{1 \leq i \leq n}
}{
	\cequalX{\aprod{\labelset}{\mapschema{\tau}{i}{\labelset}}}{\aprod{\labelset}{\mapschema{\tau'}{i}{\labelset}}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cequal-sum}
\inferrule{
	\{\cequalX{\tau_i}{\tau'_i}{\akty}\}_{1 \leq i \leq n}
}{
	\cequalX{\asum{\labelset}{\mapschema{\tau}{i}{\labelset}}}{\asum{\labelset}{\mapschema{\tau'}{i}{\labelset}}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cequal-sing}
\inferrule{
	\haskindX{c}{\aksing{c'}}
}{
	\cequalX{c}{c'}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cequal-stat}
\inferrule{
	\ismvalX{\astruct{c}{e}}\\
	\hassigX{\astruct{c}{e}}{\asignature{\kappa}{u}{\tau}}
}{
	\cequalX{\amcon{\astruct{c}{e}}}{c}{\kappa}
}
\end{equation}
\end{subequations}
\subsubsection{Expanded Expressions, Rules and Patterns}
Types, $\tau$, classify expressions. The constructors of kind $\akty$ coincide with the types of $\miniVerseParam$.
\begin{equation}\label{rule:istypeP}
\inferrule{
	\haskindX{\tau}{\akty}
}{
	\istypeP{\Omega}{\tau}
}
\end{equation}
Type equality then coincides with constructor equality at kind $\akty$.
\begin{equation}\label{rule:tequalP}
\inferrule{
	\cequalX{\tau}{\tau}{\akty}
}{
	\tequalPX{\tau}{\tau'}
}
\end{equation}

Subtyping.
\begin{subequations}\label{rules:issubtypeP}	
\begin{equation}\label{rule:issubtypeP-equal}
\inferrule{
	\tequalPX{\tau_1}{\tau_2}
}{
	\issubtypePX{\tau_1}{\tau_2}
}
\end{equation}
\begin{equation}\label{rule:issubtypeP-trans}
\inferrule{
	\issubtypePX{\tau}{\tau'}\\
	\issubtypePX{\tau'}{\tau''}
}{
	\issubtypePX{\tau}{\tau''}
}
\end{equation}
\begin{equation}\label{rule:issubtypeP-parr}
\inferrule{
	\issubtypePX{\tau_1'}{\tau_1}\\
	\issubtypePX{\tau_2}{\tau_2'}
}{
	\issubtypePX{\aparr{\tau_1}{\tau_2}}{\aparr{\tau_1'}{\tau_2'}}
}
\end{equation}
\begin{equation}\label{rule:issubtypeP-all}
\inferrule{
	\ksubX{\kappa}{\kappa'}\\
	\issubtypeP{\Omega, u :: \kappa}{\tau}{\tau'}
}{
	\issubtypePX{\aallu{\kappa}{u}{\tau}}{\aallu{\kappa'}{u}{\tau'}}
}
\end{equation}
\begin{equation}\label{rule:issubtypeP-prod}
\inferrule{
	\{\issubtypePX{\tau_i}{\tau'_i}\}_{i \in \labelset}
}{
	\issubtypePX{\aprod{\labelset}{\mapschema{\tau}{i}{\labelset}}}{\aprod{\labelset}{\mapschema{\tau'}{i}{\labelset}}}
}
\end{equation}
\begin{equation}\label{rule:issubtypeP-sum}
\inferrule{
	\{\issubtypePX{\tau_i}{\tau'_i}\}_{i \in \labelset}
}{
	\issubtypePX{\asum{\labelset}{\mapschema{\tau}{i}{\labelset}}}{\asum{\labelset}{\mapschema{\tau'}{i}{\labelset}}}
}
\end{equation}
\end{subequations}

Expression typing \todo{describe these}
\begin{subequations}\label{rules:hastypeP}
\begin{equation}\label{rule:hastypeP-subsume}
\inferrule{
	\hastypeP{\Omega}{e}{\tau}\\
	\issubtypePX{\tau}{\tau'}
}{
	\hastypeP{\Omega}{e}{\tau'}
}
\end{equation}
\begin{equation}\label{rule:hastypeP-var}
  \inferrule{ }{
    \hastypeP{\Omega, \Ghyp{x}{\tau}}{x}{\tau}
  }
\end{equation}
\begin{equation}\label{rule:hastypeP-lam}
  \inferrule{
    \istypeP{\Omega}{\tau}\\
    \hastypeP{\Omega, \Ghyp{x}{\tau}}{e}{\tau'}
  }{
    \hastypeP{\Omega}{\aelam{\tau}{x}{e}}{\aparr{\tau}{\tau'}}
  }
\end{equation}
\begin{equation}\label{rule:hastypeP-ap}
  \inferrule{
    \hastypeP{\Omega}{e_1}{\aparr{\tau}{\tau'}}\\
    \hastypeP{\Omega}{e_2}{\tau}
  }{
    \hastypeP{\Omega}{\aeap{e_1}{e_2}}{\tau'}
  }
\end{equation}
\begin{equation}\label{rule:hastypeP-clam}
  \inferrule{
  	\iskindX{\kappa}\\
    \hastypeP{\Omega, u :: \kappa}{e}{\tau}
  }{
    \hastypeP{\Omega}{\aeclam{\kappa}{u}{e}}{\aallu{\kappa}{u}{\tau}}
  }
\end{equation}
\begin{equation}\label{rule:hastypeP-cap}
  \inferrule{
    \hastypeP{\Omega}{e}{\aallu{\kappa}{u}{\tau}}\\
    \haskindX{c}{\kappa}
  }{
    \hastypeP{\Omega}{\aecap{e}{c}}{[c/u]\tau}
  }
\end{equation}
\begin{equation}\label{rule:hastypeP-fold}
  \inferrule{\
    \istypeP{\Omega, t :: \akty}{\tau}\\
    \hastypeP{\Omega}{e}{[\arec{t}{\tau}/t]\tau}
  }{
    \hastypeP{\Omega}{\aefold{t}{\tau}{e}}{\arec{t}{\tau}}
  }
\end{equation}
\begin{equation}\label{rule:hastypeP-unfold}
  \inferrule{
    \hastypeP{\Omega}{e}{\arec{t}{\tau}}
  }{
    \hastypeP{\Omega}{\aeunfold{e}}{[\arec{t}{\tau}/t]\tau}
  }
\end{equation}
\begin{equation}\label{rule:hastypeP-tpl}
  \inferrule{
    \{\hastypeP{\Omega}{e_i}{\tau_i}\}_{i \in \labelset}
  }{
    \hastypeP{\Omega}{\aetpl{\labelset}{\mapschema{e}{i}{\labelset}}}{\aprod{\labelset}{\mapschema{\tau}{i}{\labelset}}}
  }
\end{equation}
\begin{equation}\label{rule:hastypeP-pr}
  \inferrule{
    \hastypeP{\Omega}{e}{\aprod{\labelset, \ell}{\mapschema{\tau}{i}{\labelset}; \ell \hookrightarrow \tau}}
  }{
    \hastypeP{\Omega}{\aepr{\ell}{e}}{\tau}
  }
\end{equation}
\begin{equation}\label{rule:hastypeP-in}
  \inferrule{
    \{\istypeP{\Omega}{\tau_i}\}_{i \in \labelset}\\
    \istypeP{\Omega}{\tau}\\
    \hastypeP{\Omega}{e}{\tau}
  }{
    \hastypeP{\Omega}{\aein{\labelset, \ell}{\ell}{\mapschema{\tau}{i}{\labelset}; \ell \hookrightarrow \tau}{e}}{\asum{\labelset, \ell}{\mapschema{\tau}{i}{\labelset}; \ell \hookrightarrow \tau}}
  }
\end{equation}
\begin{equation}\label{rule:hastypeP-match}
\inferrule{
  \hastypeP{\Omega}{e}{\tau}\\
  \istypeP{\Omega}{\tau'}\\
  \{\ruleTypeP{\Omega}{r_i}{\tau}{\tau'}\}_{1 \leq i \leq n}\\
}{\hastypeP{\Omega}{\aematchwith{n}{\tau'}{e}{\seqschemaX{r}}}{\tau'}}
\end{equation}
\begin{equation}\label{rule:hastypeP-dyn}
\inferrule{
	\ismvalX{M}\\
	\hassigX{M}{\asignature{\kappa}{u}{\tau}}
}{
	\hastypeP{\Omega}{\amval{M}}{[\amcon{M}/u]\tau}
}
\end{equation}
\end{subequations}

Rule typing
\begin{equation}\label{rule:ruleTypeP}
\inferrule{
  \patTypeP{\Omega'}{p}{\tau}\\
  \hastypeP{\Gcons{\Omega}{\Omega'}}{e}{\tau'}
}{
	\ruleTypeP{\Omega}{\aematchrule{p}{e}}{\tau}{\tau'}
}
\end{equation}

Pattern typing
\begin{subequations}\label{rules:patTypeP}
\begin{equation}\label{rule:patTypeP-var}
\inferrule{ }{\patTypeP{\Ghyp{x}{\tau}}{x}{\tau}}
\end{equation}
\begin{equation}\label{rule:patTypeP-wild}
\inferrule{ }{\patTypeP{\emptyset}{\aewildp}{\tau}}
\end{equation}
\begin{equation}\label{rule:patTypeP-fold}
\inferrule{
  \patTypeP{\Omega'}{p}{[\arec{t}{\tau}/t]\tau}
}{
  \patTypeP{\Omega'}{\aefoldp{p}}{\arec{t}{\tau}}
}
\end{equation}
\begin{equation}\label{rule:patTypeP-tpl}
\inferrule{
  \{\patTypeP{\Omega_i}{p_i}{\tau_i}\}_{i \in \labelset}
}{
  \patTypeP{\Gconsi{i \in \labelset}{\Omega_i}}{\aetplp{\labelset}{\mapschema{p}{i}{\labelset}}}{\aprod{\labelset}{\mapschema{\tau}{i}{\labelset}}}
}
\end{equation}
\begin{equation}\label{rule:patTypeP-inj}
\inferrule{
  \patTypeP{\Omega'}{p}{\tau}
}{
  \patTypeP{\Omega'}{\aeinjp{\ell}{p}}{\asum{\labelset, \ell}{\mapschema{\tau}{i}{\labelset}; \mapitem{\ell}{\tau}}}
}
\end{equation}
\end{subequations}

\subsubsection{Signatures and Structures}
Signature formation
\begin{equation}\label{rule:issig}
\inferrule{
	\iskindX{\kappa}\\
	\istypeP{\Omega, u :: \kappa}{\tau}
}{
	\issigX{\asignature{\kappa}{u}{\tau}}
}
\end{equation}


Signature equality
\begin{equation}\label{rule:sigequal}
\inferrule{
	\kequalX{\kappa}{\kappa'}\\
	\tequalP{\Omega, u :: \kappa}{\tau}{\tau'}
}{
	\sigequalX{\asignature{\kappa}{u}{\tau}}{\asignature{\kappa'}{u}{\tau'}}
}
\end{equation}

Subsignature
\begin{equation}\label{rule:sigsub}
\inferrule{
	\ksubX{\kappa}{\kappa'}\\
	\issubtypeP{\Omega, u :: \kappa}{\tau}{\tau'}
}{
	\sigsubX{\asignature{\kappa}{u}{\tau}}{\asignature{\kappa'}{u}{\tau'}}
}
\end{equation}

Signature matching
\begin{subequations}\label{rules:hassig}
\begin{equation}\label{rule:hassig-subsume}
\inferrule{
	\hassigX{M}{\sigma}\\
	\sigsubX{\sigma}{\sigma'}
}{
	\hassigX{M}{\sigma'}
}
\end{equation}
\begin{equation}\label{rule:hassig-var}
\inferrule{ }{
	\hassig{\Omega, X : \sigma}{X}{\sigma}
}
\end{equation}
\begin{equation}\label{rule:hassig-struct}
\inferrule{
	\haskindX{c}{\kappa}\\
	\hastypeP{\Omega}{e}{[c/u]\tau}
}{
	\hassigX{\astruct{c}{e}}{\asignature{\kappa}{u}{\tau}}
}
\end{equation}
\begin{equation}\label{rule:hassig-seal}
\inferrule{
	\issigX{\sigma}\\
	\hassigX{M}{\sigma}
}{
	\hassigX{\aseal{\sigma}{M}}{\sigma}
}
\end{equation}
\begin{equation}\label{rule:hassig-let}
\inferrule{
	\hassigX{M}{\sigma}\\
	\issigX{\sigma'}\\
	\hassig{\Omega, X : \sigma}{M'}{\sigma'}	
}{
	\hassigX{\amlet{\sigma'}{M}{X}{M'}}{\sigma'}
}
\end{equation}
\end{subequations}

Module values
\begin{subequations}\label{rules:ismval}
\begin{equation}\label{rule:ismval-struct}
\inferrule{ }{
	\ismvalX{\astruct{c}{e}}
}
\end{equation}
\begin{equation}\label{rule:ismval-var}
\inferrule{ }{
	\ismval{\Omega, X : \sigma}{X}
}
\end{equation}
\end{subequations}

\todo{metatheory of statics of inner core}
\subsection{Structural Dynamics}
\todo{do this}

\begin{figure}[p] 
$\begin{array}{lrlllll}
\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{UKind} & \ukappa & ::= & \aukdarr{\ukappa}{\uu}{\ukappa} & \kdarr{\uu}{\ukappa}{\ukappa} & \text{dependent function}\\
&&& \aukunit & \kunit & \text{nullary product}\\
&&& \aukdbprod{\ukappa}{\uu}{\ukappa} & \kdbprod{\uu}{\ukappa}{\ukappa} & \text{dependent product}\\
%&&& \akdprodstd & \kdprodstd & \text{labeled dependent product}\\
&&& \aukty & \kty & \text{types}\\
&&& \auksing{\utau} & \ksing{\utau} & \text{singleton}\\
\mathsf{UCon} & \uc, \utau & ::= & \uu & \uu & \text{constructor sigil}\\
&&& \ut & \ut & \text{constructor sigil}\\
&&& \aucabs{\uu}{\uc} & \cabs{\uu}{\uc} & \text{abstraction}\\
&&& \aucapp{c}{c} & \capp{c}{c} & \text{application}\\
&&& \auctriv & \ctriv & \text{trivial}\\
&&& \aucpair{\uc}{\uc} & \cpair{\uc}{\uc} & \text{pair}\\
&&& \aucprl{\uc} & \cprl{\uc} & \text{left projection}\\
&&& \aucprr{\uc} & \cprr{\uc} & \text{right projection}\\
%&&& \adtplX & \dtplX & \text{labeled dependent tuple}\\
%&&& \adprj{\ell}{c} & \prj{c}{\ell} & \text{projection}\\
&&& \auparr{\utau}{\utau} & \parr{\utau}{\utau} & \text{partial function}\\
&&& \auallu{\ukappa}{\uu}{\utau} & \forallu{\uu}{\ukappa}{\utau} & \text{polymorphic}\\
&&& \aurec{\ut}{\utau} & \rect{\ut}{\utau} & \text{recursive}\\
&&& \auprod{\labelset}{\mapschema{\utau}{i}{\labelset}} & \prodt{\mapschema{\utau}{i}{\labelset}} & \text{labeled product}\\
&&& \ausum{\labelset}{\mapschema{\utau}{i}{\labelset}} & \sumt{\mapschema{\utau}{i}{\labelset}} & \text{labeled sum}\\
&&& \aumcon{\uX} & \mcon{\uX} & \text{constructor part}
\end{array}$
\caption[Syntax of unexpanded kinds and constructors in $\miniVerseParam$]{Syntax of unexpanded kinds and constructors in $\miniVerseParam$. By convention, we choose the metavariable $\utau$ for constructors that, in well-formed terms, must necessarily expand to constructors of kind $\kty$, and the metavariable $\uc$ otherwise. Similarly, we choose metavariables $\ut$ for constructor sigils that expand to constructor variables that stand for constructors of kind $\kty$, and constructor sigils $\uu$ otherwise. Unexpanded kinds and constructors are not identified up to $\alpha$-equivalence.}
\label{fig:P-unexpanded-kinds-constructors}
\end{figure}

\begin{figure}
\hspace{-8px}$\arraycolsep=4pt\begin{array}{lllllll}
\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{UExp} & \ue & ::= & \ux & \ux & \text{sigil}\\
&&& \auasc{\utau}{\ue} & \asc{\ue}{\utau} & \text{ascription}\\
&&& \auletsyn{\ux}{\ue}{\ue} & \letsyn{\ux}{\ue}{\ue} & \text{value binding}\\
&&& \auanalam{\ux}{\ue} & \analam{\ux}{\ue} & \text{abstraction (unannotated)}\\
&&& \aulam{\utau}{\ux}{\ue} & \lam{\ux}{\utau}{\ue} & \text{abstraction (annotated)}\\
&&& \auap{\ue}{\ue} & \ap{\ue}{\ue} & \text{application}\\
&&& \auclam{\ukappa}{\uu}{\ue} & \clam{\uu}{\ukappa}{\ue} & \text{constructor abstraction}\\
&&& \aucap{\ue}{\uc} & \cAp{\ue}{\uc} & \text{constructor application}\\
&&& \auanafold{\ue} & \fold{\ue} & \text{fold}\\
&&& \auunfold{\ue} & \unfold{\ue} & \text{unfold}\\
&&& \autpl{\labelset}{\mapschema{\ue}{i}{\labelset}} & \tpl{\mapschema{\ue}{i}{\labelset}} & \text{labeled tuple}\\
&&& \aupr{\ell}{\ue} & \prj{\ue}{\ell} & \text{projection}\\
&&& \auanain{\ell}{\ue} & \inj{\ell}{\ue} & \text{injection}\\
&&& \aumatchwithb{n}{\ue}{\seqschemaX{\urv}} & \matchwith{\ue}{\seqschemaX{\urv}} & \text{match}\\
&&& \aumval{\uX} & \mval{\uX} & \text{value part}\\
\LCC &&& \lightgray & \lightgray & \lightgray \\
&&& \audefpetsm{\urho}{e}{\tsmv}{\ue} & \texttt{syntax}~\tsmv~\texttt{at}~\urho~\texttt{for} & \text{peTSM definition}\\
&&&                                    & \texttt{expressions}~\{e\}~\texttt{in}~\ue\\
&&& \auletpetsm{\uepsilon}{\tsmv}{\ue} & \texttt{let}~\texttt{syntax}~\tsmv=\uepsilon~\texttt{for} & \text{peTSM binding}\\
&&&                                  & \texttt{expressions}~\texttt{in}~\ue\\
&&& ... & ... & \text{peTSM designation}\\
&&& \auappetsm{b}{\uepsilon} & \utsmap{\uepsilon}{b} & \text{peTSM application}\\%\ECC
&&& \auelit{b} & {\lit{b}}  & \text{peTSM unadorned literal}\\
&&& \audefpptsm{\urho}{e}{\tsmv}{\ue} & \texttt{syntax}~\tsmv~\texttt{at}~\urho~\texttt{for} & \text{ppTSM definition}\\
&&&                                    & \texttt{patterns}~\{e\}~\texttt{in}~\ue\\
&&& \auletpptsm{\uepsilon}{\tsmv}{\ue} & \texttt{let}~\texttt{syntax}~\tsmv=\uepsilon~\texttt{for} & \text{ppTSM binding}\\
&&& & \texttt{patterns}~\texttt{in}~\ue\\
&&& ... & ... & \text{ppTSM designation}\\\ECC
\mathsf{URule} & \urv & ::= & \aumatchrule{\upv}{\ue} & \matchrule{\upv}{\ue} & \text{match rule}\\
\mathsf{UPat} & \upv & ::= & \ux & \ux & \text{sigil pattern}\\
&&& \auwildp & \wildp & \text{wildcard pattern}\\
&&& \aufoldp{\upv} & \foldp{\upv} & \text{fold pattern}\\
&&& \autplp{\labelset}{\mapschema{\upv}{i}{\labelset}} & \tplp{\mapschema{\upv}{i}{\labelset}} & \text{labeled tuple pattern}\\
&&& \auinjp{\ell}{\upv} & \injp{\ell}{\upv} & \text{injection pattern}\\
\LCC &&& \lightgray & \lightgray & \lightgray\\
&&& \auappptsm{b}{\uepsilon} & \utsmap{\uepsilon}{b} & \text{ppTSM application}\\
&&& \auplit{b} & \lit{b} & \text{ppTSM unadorned literal}\ECC
\end{array}$
\caption[Syntax of unexpanded expressions, rules and patterns in $\miniVerseParam$]{Abstract syntax of unexpanded expressions, rules and patterns in $\miniVerseParam$.}
\label{fig:P-unexpanded-terms}
\end{figure}


\begin{figure}[p] 
\hspace{-5px}$\arraycolsep=4pt\begin{array}{lllllll}
\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{USig} & \usigma & ::= & \ausignature{\ukappa}{\uu}{\utau} & \signature{\uu}{\ukappa}{\utau} & \text{signature}\\
\mathsf{UMod} & \uM & ::= & \uX & \uX & \text{module sigil}\\
&&& \austruct{\uc}{\ue} & \struct{\uc}{\ue} & \text{structure}\\
&&& \auseal{\usigma}{\uM} & \seal{\uM}{\usigma} & \text{seal}\\
&&& \aumlet{\usigma}{\uM}{\uX}{\uM} & \mlet{\uX}{\uM}{\uM}{\usigma} & \text{definition}\\
\LCC &&& \lightgray & \lightgray & \lightgray\\
&&& \aumdefpetsm{\urho}{e}{\tsmv}{\uM} & \texttt{syntax}~\tsmv~\texttt{at}~\urho~\texttt{for} & \text{peTSM definition}\\
&&&                                    & \texttt{expressions}~\{e\}~\texttt{in}~\uM\\
&&& \aumletpetsm{\uepsilon}{\tsmv}{\uM} & \texttt{let}~\texttt{syntax}~\tsmv=\uepsilon~\texttt{for} & \text{peTSM binding}\\
&&&                                  & \texttt{expressions}~\texttt{in}~\uM\\
&&& ... & ... & \text{peTSM designation}\\
&&& \audefpptsm{\urho}{e}{\tsmv}{\uM} & \texttt{syntax}~\tsmv~\texttt{at}~\urho~\texttt{for} & \text{ppTSM definition}\\
&&&                                    & \texttt{patterns}~\{e\}~\texttt{in}~\uM\\
&&& \auletpptsm{\uepsilon}{\tsmv}{\uM} & \texttt{let}~\texttt{syntax}~\tsmv=\uepsilon~\texttt{for} & \text{ppTSM binding}\\
&&& & \texttt{patterns}~\texttt{in}~\uM\\
&&& ... & ... & \text{ppTSM designation}\ECC
\end{array}$
\caption[Syntax of unexpanded module expressions and signatures in $\miniVerseParam$]{Abstract syntax of unexpanded module expressions and signatures in $\miniVerseParam$.}
\label{fig:P-unexpanded-modules-signatures}
\end{figure}


\begin{figure}
\hspace{-8px}$\arraycolsep=4pt\begin{array}{lllllll}
\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{MType} & \rho & ::= & \aetype{\tau} & \tau & \text{type annotation}\\
&&& \aealltypes{t}{\rho} & \alltypes{t}{\rho} & \text{type abstraction}\\
&&& \aeallmods{\sigma}{X}{\rho} & \allmods{X}{\sigma}{\rho} & \text{module abstraction}\\
\mathsf{UMType} & \urho & ::= & \autype{\utau} & \utau & \text{type annotation}\\
&&& \aualltypes{\ut}{\urho} & \alltypes{\ut}{\urho} & \text{type abstraction}\\
&&& \auallmods{\usigma}{\uX}{\urho} & \allmods{\uX}{\usigma}{\urho} & \text{module abstraction}\\
\mathsf{MExp} & \epsilon & ::= & \adefref{a} & a & \text{TSM definition reference}\\
&&& \aeaptype{\tau}{\epsilon} & \aptype{\epsilon}{\tau} & \text{type application}\\
&&& \aeapmod{M}{\epsilon} & \aptype{\epsilon}{M} & \text{module application}\\
\mathsf{UMExp} & \uepsilon & ::= & \abindref{\tsmv} & \tsmv & \text{TSM binding reference}\\
&&& \auaptype{\utau}{\uepsilon} & \aptype{\uepsilon}{\utau} & \text{type application}\\
&&& \auapmod{\uM}{\uepsilon} & \apmod{\uepsilon}{\uM} & \text{module application}
\end{array}$
\caption[Syntax of TSM types and expressions in $\miniVerseParam$]{Abstract syntax of TSM types, unexpanded TSM types, TSM expressions and unexpanded TSM expressions in $\miniVerseParam$.}
\label{fig:P-macro-expressions-types}
\end{figure}

\subsection{Syntax of the Surface Language}
\subsubsection{Syntax of the Surface Core Language}
Unexpanded kinds and constructors in Figure \ref{fig:P-unexpanded-kinds-constructors}

Unexpanded expressions, rules and patterns in Figure \ref{fig:P-unexpanded-terms}
\subsubsection{Syntax of the TSM Language}
Macro types, unexpanded macro types, macro expressions and unexpanded macro expressions in Figure \ref{fig:P-macro-expressions-types}
\subsubsection{Syntax of Type Patterns}
\todo{do this}
\subsubsection{Syntax of the Surface Module Language}
Figure \ref{fig:P-unexpanded-modules-signatures}

\subsection{Typed Expansion}
Unexpanded kinds and constructors

\vspace{10px}
$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\kExpandsX{\ukappa}{\kappa} & \text{$\ukappa$ is well-formed and has expansion $\kappa$}\\
\cExpandsX{\uc}{c}{\kappa} & \text{$\uc$ has expansion $c$ and kind $\kappa$}
\end{array}$
\vspace{10px}

Unexpanded types, expressions, rules and patterns

\vspace{10px}
$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\tExpandsPX{\utau}{\tau} & \text{$\utau$ has expansion $\tau$}\\
\esynPX{\ue}{e}{\tau} & \text{$\ue$ has expansion $e$ and synthesizes type $\tau$}\\
\eanaPX{\ue}{e}{\tau} & \text{$\ue$ has expansion $e$ when analyzed against type $\tau$}\\
\rsynPX{\urv}{r}{\tau}{\tau'} & \text{$\urv$ has expansion $r$ and takes values of type $\tau$ to values of}\\
& \text{synthesized type $\tau'$}\\
\ranaPX{\urv}{r}{\tau}{\tau'} & \text{$\urv$ has expansion $r$ and takes values of type $\tau$ to values of}\\
& \text{type $\tau'$ when $\tau's$ is provided for analysis}\\
\patExpandsP{\uOmega}{\uPhi}{\upv}{p}{\tau} & \text{$\upv$ has expansion $p$ and type $\tau$ and generates hypotheses $\uOmega$}
\end{array}$
\vspace{10px}

Unexpanded signatures and module expressions

\vspace{10px}
$\begin{array}{ll}
\textbf{Judgement Form} & \textbf{Description}\\
\sigExpandsPX{\usigma}{\sigma} & \text{$\usigma$ has expansion $\sigma$}\\
\mExpandsPX{\uM}{M}{\sigma} & \text{$\uM$ has expansion $M$ and matches $\sigma$}
\end{array}$
\vspace{10px}

A \emph{unified outer context}, $\uOmega$, takes the form $\uOmegaEx{\uD}{\uG}{\uMctx}{\Omega}$, where $\uD$ is a \emph{constructor sigil expansion context}, $\uG$ is an \emph{expression sigil expansion context}, $\uMctx$ is a \emph{module sigil expansion context} and $\Omega$ is a unified inner context.

A constructor sigil expansion context, $\uD$, is a finite function that maps each constructor sigil $\uu \in \domof{\uD}$ to the constructor sigil expansion $\vExpands{\uu}{u}$. We write $\uOmega, \uKhyp{\uu}{u}{\kappa}$ when $\uOmega=\uOmegaEx{\uD}{\uG}{\uMctx}{\Omega}$ as an abbreviation of \[\uOmegaEx{\uD \uplus \vExpands{\uu}{u}}{\uG}{\uMctx}{\Omega, u :: \kappa}\]

An expression sigil expansion context, $\uG$, is a finite function that maps each expression sigil $\ux \in \domof{\uG}$ to the expression sigil expansion $\vExpands{\ux}{x}$. We write $\uOmega, \uGhyp{\ux}{x}{\tau}$ when $\uOmega=\uOmegaEx{\uD}{\uG}{\uMctx}{\Omega}$ as an abbreviation of \[\uOmegaEx{\uD}{\uG \uplus \vExpands{\ux}{x}}{\uMctx}{\Omega, x : \tau}\]

A module sigil expansion context, $\uMctx$, is a finite function that maps each module sigil $\uX \in \domof{\uMctx}$ to the module sigil expansion $\vExpands{\uX}{X}$. We write $\uOmega, \uMhyp{\uX}{X}{\sigma}$ when $\uOmega=\uOmegaEx{\uD}{\uG}{\uMctx}{\Omega}$ as an abbreviation of \[\uOmegaEx{\uD}{\uG}{\uMctx \uplus \vExpands{\uX}{X}}{\Omega, X : \sigma}\]

A \emph{peTSM context}, $\uPsi$, takes the form $\uASI{\uA}{\Psi}{\uI}$ where $\uA$ is a \emph{TSM binding context}, $\Psi$ is a \emph{peTSM definition context}, and $\uI$ is \todo{implicits}. Similarly, a \emph{ppTSM context}, $\uPhi$, takes the form $\uASI{\uA}{\Phi}{\uI}$ where $\Phi$ is a \emph{ppTSM definition context}.

A \emph{TSM binding context}, $\uA$, is a finite function that maps each TSM name $\tsmv \in \domof{\uA}$ to a \emph{TSM binding}, $\mapitem{\tsmv}{\epsilon}$, for some TSM expression, $\epsilon$.

A \emph{peTSM definition context}, $\Psi$, is a finite function that maps each symbol $a \in \domof{\Psi}$ to a \emph{peTSM definition}, $\petsmdefn{a}{\rho}{\eparse}$ for some TSM type $\rho$ and expanded expression $\eparse$.

Similarly, a \emph{ppTSM definition context}, $\Phi$, is a finite function that maps each symbol $a \in \domof{\Phi}$ to a \emph{ppTSM definition}, $\pptsmdefn{a}{\rho}{\eparse}$ for some TSM type $\rho$ and expanded expression $\eparse$.

\subsubsection{Kinds and Constructors}
Kind expansion

\begin{subequations}\label{rules:kExpands}
\begin{equation}\label{rule:kExpands-darr}
\inferrule{
	\kExpandsX{\ukappa_1}{\kappa_1}\\
	\kExpands{\uOmega, \uKhyp{\uu}{u}{\kappa_1}}{\ukappa_2}{\kappa_2}
}{
	\kExpandsX{\aukdarr{\ukappa_1}{\uu}{\ukappa_2}}{\akdarr{\kappa_1}{u}{\kappa_2}}
}
\end{equation}
\begin{equation}\label{rule:kExpands-unit}
\inferrule{ }{
	\kExpandsX{\aukunit}{\akunit}
}
\end{equation}
\begin{equation}\label{rule:kExpands-dprod}
\inferrule{
	\kExpandsX{\ukappa_1}{\kappa_1}\\
	\kExpands{\uOmega, \uKhyp{\uu}{u}{\kappa_1}}{\ukappa_2}{\kappa_2}
}{
	\kExpandsX{\aukdbprod{\ukappa_1}{\uu}{\ukappa_2}}{\akdbprod{\kappa_1}{u}{\kappa_2}}
}
\end{equation}
\begin{equation}\label{rule:kExpands-ty}
\inferrule{ }{
	\kExpandsX{\aukty}{\akty}
}
\end{equation}
\begin{equation}\label{rule:kExpands-sing}
\inferrule{
	\cExpandsX{\utau}{\tau}{\akty}
}{
	\kExpandsX{\auksing{\utau}}{\aksing{\tau}}
}
\end{equation}
\end{subequations}

Constructor expansion
\begin{subequations}\label{rules:cExpands}
\begin{equation}\label{rule:cExpands-subsume}
\inferrule{
	\cExpandsX{\uc}{c}{\kappa_1}\\
	\ksubX{\kappa_1}{\kappa_2}
}{
	\cExpandsX{\uc}{c}{\kappa_2}
}
\end{equation}
\begin{equation}\label{rule:cExpands-var}
\inferrule{ }{\cExpands{\uOmega, \uKhyp{\uu}{u}{\kappa}}{\uu}{u}{\kappa}}
\end{equation}
\begin{equation}\label{rule:cExpands-abs}
\inferrule{
	\cExpands{\uOmega, \uKhyp{\uu}{u}{\kappa_1}}{\uc_2}{c_2}{\kappa_2}
}{
	\cExpandsX{\aucabs{\uu}{\uc_2}}{\acabs{u}{c_2}}{\akdarr{\kappa_1}{u}{\kappa_2}}
}
\end{equation}
\begin{equation}\label{rule:cExpands-app}
\inferrule{
	\cExpandsX{\uc_1}{c_1}{\akdarr{\kappa_2}{u}{\kappa}}\\
	\cExpandsX{\uc_2}{c_2}{\kappa_2}
}{
	\cExpandsX{\aucapp{\uc_1}{\uc_2}}{\acapp{c_1}{c_2}}{[c_1/u]\kappa}
}
\end{equation}
\begin{equation}\label{rule:cExpands-unit}
\inferrule{ }{
	\cExpandsX{\auctriv}{\actriv}{\akunit}
}
\end{equation}
\begin{equation}\label{rule:cExpands-pair}
\inferrule{
	\cExpandsX{\uc_1}{c_1}{\kappa_1}\\
	\cExpandsX{\uc_2}{c_2}{[c_1/u]\kappa_2}
}{
	\cExpandsX{\aucpair{\uc_1}{\uc_2}}{\acpair{c_1}{c_2}}{\akdbprod{\kappa_1}{u}{\kappa_2}}
}
\end{equation}
\begin{equation}\label{rule:cExpands-prl}
\inferrule{
	\cExpandsX{\uc}{c}{\akdbprod{\kappa_1}{u}{\kappa_2}}
}{
	\cExpandsX{\aucprl{\uc}}{\acprl{c}}{\kappa_1}
}
\end{equation}
\begin{equation}\label{rule:cExpands-prr}
\inferrule{
	\cExpandsX{\uc}{c}{\akdbprod{\kappa_1}{u}{\kappa_2}}
}{
	\cExpandsX{\aucprr{\uc}}{\acprr{c}}{[\acprl{c}/u]\kappa_2}
}
\end{equation}
\begin{equation}\label{rule:cExpands-parr}
\inferrule{
	\cExpandsX{\utau_1}{\tau_1}{\akty}\\
	\cExpandsX{\utau_2}{\tau_2}{\akty}
}{
	\cExpandsX{\auparr{\utau_1}{\utau_2}}{\aparr{\tau_1}{\tau_2}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cExpands-all}
\inferrule{
	\kExpandsX{\ukappa}{\kappa}\\
	\cExpands{\uOmega, \uKhyp{\uu}{u}{\kappa}}{\utau}{\tau}{\akty}
}{
	\cExpandsX{\auallu{\ukappa}{\uu}{\utau}}{\aallu{\kappa}{u}{\tau}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cExpands-rec}
\inferrule{
	\cExpands{\uOmega, \uKhyp{\ut}{t}{\akty}}{\utau}{\tau}{\akty}
}{
	\cExpandsX{\aurec{\ut}{\utau}}{\arec{t}{\tau}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cExpands-prod}
\inferrule{
	\{\cExpandsX{\utau_i}{\tau_i}{\akty}\}_{1 \leq i \leq n}
}{
	\cExpandsX{\auprod{\labelset}{\mapschema{\utau}{i}{\labelset}}}{\aprod{\labelset}{\mapschema{\tau}{i}{\labelset}}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cExpands-sum}
\inferrule{
	\{\cExpandsX{\utau_i}{\tau_i}{\akty}\}_{1 \leq i \leq n}
}{
	\cExpandsX{\ausum{\labelset}{\mapschema{\utau}{i}{\labelset}}}{\asum{\labelset}{\mapschema{\tau}{i}{\labelset}}}{\akty}
}
\end{equation}
\begin{equation}\label{rule:cExpands-sing}
\inferrule{
	\cExpandsX{\uc}{c}{\akty}
}{
	\cExpandsX{\uc}{c}{\aksing{c}}
}
\end{equation}
\begin{equation}\label{rule:cExpands-stat}
\inferrule{ }{
	\cExpands{\uOmega, \uMhyp{\uX}{X}{\asignature{\kappa}{u}{\tau}}}{\aumcon{\uX}}{\amcon{X}}{\kappa}
}
\end{equation}
\end{subequations}

\subsubsection{Types, Expressions, Rules and Patterns}
\begin{equation}\label{rule:tExpandsP}
\inferrule{
	\cExpandsX{\utau}{\tau}{\akty}
}{
	\tExpandsPX{\utau}{\tau}
}
\end{equation}

Synthetic typed expression expansion
\begin{subequations}\label{rules:esynP}
\begin{equation}\label{rule:esynP-var}
  \inferrule{ }{ 
    \esynP{\Omega, \uGhyp{\ux}{x}{\tau}}{\uPsi}{\uPhi}{\ux}{x}{\tau}
  }
\end{equation}

%A \emph{type ascription} can be placed on an unexpanded expression to specify the type that it should be analyzed against. The ascribed type is synthesized if type analysis succeeds.
\begin{equation}\label{rule:esynP-asc}
  \inferrule{
    \tExpandsPX{\utau}{\tau}\\
    \eanaPX{\ue}{e}{\tau}
  }{
    \esynPX{\auasc{\utau}{\ue}}{e}{\tau}
  }
\end{equation}

%We define let-binding of a value in synthetic position primitively in $\miniVerseUB$. The following rule governs such bindings in synthetic position.
\begin{equation}\label{rule:esynP-let}
  \inferrule{
    \esynPX{\ue}{e}{\tau}\\
    \esynP{\uOmega, \uGhyp{\ux}{x}{\tau}}{\uPsi}{\uPhi}{\ue'}{e'}{\tau'}
  }{
    \esynPX{\auletsyn{\ux}{\ue}{\ue'}}{\aeap{\aelam{\tau}{x}{e'}}{e}}{\tau'}
  }
\end{equation}

%Functions with an argument type annotation can appear in synthetic position.
\begin{equation}\label{rule:esynP-lam}
  \inferrule{
    \tExpandsPX{\utau_1}{\tau_1}\\
    \esynP{\uOmega, \uGhyp{\ux}{x}{\tau_1}}{\uPsi}{\uPhi}{\ue}{e}{\tau_2}
  }{
    \esynPX{\aulam{\utau_1}{\ux}{\ue}}{\aelam{\tau_1}{x}{e}}{\aparr{\tau_1}{\tau_2}}
  }
\end{equation}

%Function applications can appear in synthetic position. The argument is analyzed against the argument type synthesized by the function.
\begin{equation}\label{rule:esynP-ap}
  \inferrule{
    \esynPX{\ue_1}{e_1}{\aparr{\tau_2}{\tau}}\\
    \eanaPX{\ue_2}{e_2}{\tau_2}
  }{
    \esynPX{\auap{\ue_1}{\ue_2}}{\aeap{e_1}{e_2}}{\tau}
  }
\end{equation}

%Type lambdas and type applications can appear in synthetic position.
\begin{equation}\label{rule:esynP-tlam}
  \inferrule{
  	\kExpandsX{\ukappa}{\kappa}\\
    \esynP{\uOmega, \uKhyp{\uu}{u}{\kappa}}{\uPsi}{\uPhi}{\ue}{e}{\tau}
  }{
    \esynPX{\auclam{\ukappa}{\uu}{\ue}}{\aeclam{\kappa}{u}{e}}{\aallu{\kappa}{u}{\tau}}
  }
\end{equation}
\begin{equation}\label{rule:esynP-tap}
  \inferrule{
    \esynPX{\ue}{e}{\aallu{\kappa}{u}{\tau}}\\
    \cExpandsX{\uc}{c}{\kappa}
  }{
    \esynPX{\aucap{\ue}{\uc}}{\aecap{e}{c}}{[c/t]\tau}
  }
\end{equation}

%Unfoldings can appear in synthetic position.
\begin{equation}\label{rule:esynP-unfold}
  \inferrule{
    \esynPX{\ue}{e}{\arec{t}{\tau}}
  }{
    \esynPX{\auunfold{\ue}}{\aeunfold{e}}{[\arec{t}{\tau}/t]\tau}
  }
\end{equation}

%Labeled tuples can appear in synthetic position. Each of the field values are then in synthetic position. 
\begin{equation}\label{rule:esynP-tpl}
  \inferrule{
  	\ue=\autpl{\labelset}{\mapschema{\ue}{i}{\labelset}}\\
  	e=\aetpl{\labelset}{\mapschema{e}{i}{\labelset}}\\\\
    \{\esynPX{\ue_i}{e_i}{\tau_i}\}_{i \in \labelset}
  }{
    \esynPX{\ue}{e}{\aprod{\labelset}{\mapschema{\tau}{i}{\labelset}}}
  }
\end{equation}

%Fields can be projected out of a labeled tuple in synthetic position.
\begin{equation}\label{rule:esynP-pr}
  \inferrule{
    \esynPX{\ue}{e}{\aprod{\labelset, \ell}{\mapschema{\tau}{i}{\labelset}; \mapitem{\ell}{\tau}}}
  }{
    \esynPX{\aupr{\ell}{\ue}}{\aepr{\ell}{e}}{\tau}
  }
\end{equation}

%Match expressions can appear in synthetic position.
\begin{equation}\label{rule:esynP-match}
  \inferrule{
    \esynPX{\ue}{e}{\tau}\\
    \{\rsynPX{\urv_i}{r_i}{\tau}{\tau'}\}_{1 \leq i \leq n}
  }{
    \esynPX{\aumatchwithb{n}{\ue}{\seqschemaX{\urv}}}{\aematchwith{n}{\tau'}{e}{\seqschemaX{r}}}{\tau'}
  }
\end{equation}
\end{subequations}

\todo{these rules}
\begin{subequations}[resume]
% ueTSMs can be defined and applied in synthetic position.
\begin{equation}\label{rule:esynP-defuetsm}
\inferrule{
	\tsmtyExpands{\Omega}{\urho}{\rho}\\
  \hastypeP{\emptyset}{\eparse}{\aparr{\tBody}{\tParseResultCEExpBnd}}\\\\
  \uPsi=\uASI{\uA}{\Psi}{\uI}\\
  \esyn{\uDelta}{\uGamma}{\uASI{\uA \uplus \mapitem{\tsmv}{\adefref{a}}}{\Psi, \petsmdefn{a}{\rho}{\eparse}}{\uI}}{\uPhi}{\ue}{e}{\tau'}
}{
  \esynPX{\usyntaxueP{\tsmv}{\urho}{\eparse}{\ue}}{e}{\tau'}
}
\end{equation}

ParseResult...

CEExpBnd...

\begin{equation}\label{rule:esynP-apuetsm}
\inferrule{
  \encodeBody{b}{\ebody}\\
  \evalU{\ap{\eparse}{\ebody}}{\inj{\lbltxt{Success}}{\ecand}}\\
  \decodeCondE{\ecand}{\ce}\\\\
  \cana{\emptyset}{\emptyset}{\esceneUP{\uDelta}{\uGamma}{\uPsi, \uShyp{\tsmv}{a}{\tau}{\eparse}}{\uPhi}{b}}{\ce}{e}{\tau}
}{
  \esyn{\uDelta}{\uGamma}{\uPsi, \uShyp{\tsmv}{a}{\tau}{\eparse}}{\uPhi}{\utsmap{\tsmv}{b}}{e}{\tau}
}
\end{equation}
% These rules are nearly identical to Rules (\ref{rule:expandsUP-syntax}) and (\ref{rule:expandsUP-tsmap}), differing only in that the typed expansion premises have been replaced by corresponding synthetic typed expansion premises. The premises of these rules can be understood as described in Sections \ref{sec:U-uetsm-definition} and \ref{sec:U-uetsm-application}. The body encoding judgement and candidate expansion expression decoding judgements were characterized in Sec. \ref{sec:typed-expansion-UP}. We discuss candidate expansion validation in Sec. \ref{sec:ce-validation-B} below.

% To support ueTSM implicits, ueTSM contexts, $\uPsi$, are redefined to take the form $\uASI{\uA}{\Psi}{\uI}$. TSM naming contexts, $\uA$, and ueTSM definition contexts, $\Psi$, were defined in Sec. \ref{sec:typed-expansion-UP}. We write $\uPsi, \uShyp{\tsmv}{a}{\tau}{\eparse}$ when $\uPsi=\uASI{\uA}{\Psi}{\uI}$ as shorthand for \[\uASI{\ctxUpdate{\uA}{\tsmv}{a}}{\Psi, \xuetsmbnd{a}{\tau}{\eparse}}{\uI}\]

% \emph{TSM designation contexts}, $\uI$, are finite functions that map each type $\tau \in \domof{\uI}$ to the \emph{TSM designation} $\designate{\tau}{a}$, for some symbol $a$. We write $\uI \uplus \designate{\tau}{a}$ for the TSM designation context that maps $\tau$ to $\designate{\tau}{a}$ and defers to $\uI$ for all other types (i.e. the previous designation, if any, is updated). 

% The TSM designation context in the ueTSM context is updated by expressions of ueTSM designation form. Such expressions can appear in synthetic position, where they are governed by the following rule:% We write $\uIOK{\Delta}{\uI}$ when each type in $\uI$ is well-formed assuming $\Delta$.
%\begin{definition}[TSM Designation Context Well-Formedness] $\uIOK{\Delta}{{\uI}$ iff for each $\designate{\tau}{a}$ we have $\istypeU{\Delta}{\tau}$.\end{definition}
\begin{equation}\label{rule:esynP-implicite}
  \inferrule{
    \esyn{\uDelta}{\uGamma}{\uASI{\uA \uplus \vExpands{\tsmv}{a}}{\Psi, \xuetsmbnd{a}{\tau}{\eparse}}{\uI \uplus \designate{\tau}{a}}}{\uPhi}{\ue}{e}{\tau'}
  }{
    \esyn{\uDelta}{\uGamma}{\uASI{\uA \uplus \vExpands{\tsmv}{a}}{\Psi, \xuetsmbnd{a}{\tau}{\eparse}}{\uI}}{\uPhi}{\implicite{\tsmv}{\ue}}{e}{\tau'}
  }
\end{equation}

% Like ueTSMs, upTSMs can be defined in synthetic position.
\begin{equation}\label{rule:esynP-defuptsm}
\inferrule{
  \expandsTU{\uDelta}{\utau}{\tau}\\
  \hastypeU{\emptyset}{\emptyset}{\eparse}{\aparr{\tBody}{\tParseResultPat}}\\\\
  \esyn{\uDelta}{\uGamma}{\uPsi}{\uPhi, \uPhyp{\tsmv}{a}{\tau}{\eparse}}{\ue}{e}{\tau'}
}{
  \esynPX{\usyntaxup{\tsmv}{\utau}{\eparse}{\ue}}{e}{\tau'}
}
\end{equation}
% This rule is nearly identical to Rule (\ref{rule:expandsUP-defuptsm}), differing only in that the typed expansion premise has been replaced by the corresponding synthetic typed expansion premise. The premises can be understood as described in Section \ref{sec:uptsm-definition}.

% To support upTSM implicits, upTSM contexts, $\uPhi$, are redefined to take the form $\uASI{\uA}{\Phi}{\uI}$. upTSM definition contexts, $\Phi$, were defined in Sec. \ref{sec:uptsm-definition}. We write $\uPhi, \uPhyp{\tsmv}{a}{\tau}{\eparse}$ when $\uPhi=\uASI{\uA}{\Phi}{\uI}$ as shorthand for \[\uASI{\ctxUpdate{\uA}{\tsmv}{a}}{\Phi, \xuptsmbnd{a}{\tau}{\eparse}}{\uI}\]

% The TSM designation context in the upTSM context is updated by expressions of upTSM designation form. Such expressions can appear in synthetic position, where they are governed by the following rule:% We write $\uIOK{\Delta}{\uI}$ when each type in $\uI$ is well-formed assuming $\Delta$.
%\begin{definition}[TSM Designation Context Well-Formedness] $\uIOK{\Delta}{{\uI}$ iff for each $\designate{\tau}{a}$ we have $\istypeU{\Delta}{\tau}$.\end{definition}
\begin{equation}\label{rule:esynP-implicitp}
  \inferrule{
    \esyn{\uDelta}{\uGamma}{\uPsi}{\uASI{\uA\uplus\vExpands{\tsmv}{a}}{\Phi, \xuptsmbnd{a}{\tau}{\eparse}}{\uI \uplus \designate{\tau}{a}}}{\ue}{e}{\tau'}
  }{
    \esyn{\uDelta}{\uGamma}{\uPsi}{\uASI{\uA\uplus\vExpands{\tsmv}{a}}{\Phi, \xuetsmbnd{a}{\tau}{\eparse}}{\uI}}{\implicitp{\tsmv}{\ue}}{e}{\tau'}
  }
\end{equation}
\end{subequations}


Analytic typed expression expansion
\begin{subequations}\label{rules:eanaP}
% Type analysis subsumes type synthesis, in that when a type can be synthesized for an unexpanded expression, that unexpanded expression can also be analyzed against that type, producing the same expansion. This is expressed by the following \emph{subsumption rule} for unexpanded expressions.
\begin{equation}\label{rule:eanaP-subsume}
  \inferrule{
    \esynPX{\ue}{e}{\tau}\\
    \issubtypePX{\tau}{\tau'}
  }{
    \eanaPX{\ue}{e}{\tau'}
  }
\end{equation}

% Additional rules are needed for certain forms in order to propagate types for analysis into subexpressions, and for forms that can appear only in analytic position.

% Rule (\ref{rule:esyn-let}) governed value bindings in synthetic position. The following rule governs value bindings in analytic position.
\begin{equation}\label{rule:eanaP-let}
  \inferrule{
    \esynPX{\ue}{e}{\tau}\\
    \eanaP{\uOmega, \uGhyp{\ux}{x}{\tau}}{\uPsi}{\uPhi}{\ue'}{e'}{\tau'}
  }{
    \eanaPX{\auletsyn{\ux}{\ue}{\ue'}}{\aeap{\aelam{\tau}{x}{e'}}{e}}{\tau'}
  }
\end{equation}

% An unannotated function can appear only in analytic position. The argument type is determined from the type that the unannotated function is being analyzed against. 
\begin{equation}\label{rule:eanaP-analam}
  \inferrule{
    \eanaP{\uOmega, \uGhyp{\ux}{x}{\tau_1}}{\uPsi}{\uPhi}{\ue}{e}{\tau_2}
  }{
    \eanaPX{\auanalam{\ux}{\ue}}{\aelam{\tau_1}{x}{e}}{\aparr{\tau_1}{\tau_2}}
  }
\end{equation}

% Rule (\ref{rule:esyn-tlam}) governed type lambdas in synthetic position. The following rule governs type lambdas in analytic position.
\begin{equation}\label{rule:eanaP-tlam}
  \inferrule{
    \eana{\uDelta, \uDhyp{\ut}{t}}{\uGamma}{\uPsi}{\uPhi}{\ue}{e}{\tau}
  }{
    \eanaPX{\autlam{\ut}{\ue}}{\aetlam{t}{e}}{\aall{t}{\tau}}
  }
\end{equation}

% Values of recursive types can be introduced only in analytic position.
\begin{equation}\label{rule:eanaP-fold}
  \inferrule{
    \eanaPX{\ue}{e}{[\arec{t}{\tau}/t]\tau}
  }{
    \eanaPX{\auanafold{\ue}}{\aefold{t}{\tau}{e}}{\arec{t}{\tau}}
  }
\end{equation}

% Rule (\ref{rule:esyn-tpl}) governed labeled tuples in synthetic position. The following rule governs labeled tuples in analytic position.
\begin{equation}\label{rule:eanaP-tpl}
  \inferrule{
  	\ue=\autpl{\labelset}{\mapschema{\ue}{i}{\labelset}}\\
  	e=\aetpl{\labelset}{\mapschema{e}{i}{\labelset}}\\\\
    \{\eanaPX{\ue_i}{e_i}{\tau_i}\}_{i \in \labelset}
  }{
    \eanaPX{\ue}{e}{\aprod{\labelset}{\mapschema{\tau}{i}{\labelset}}}
  }
\end{equation}

% Values of labeled sum type can appear only in analytic position.
\begin{equation}\label{rule:eanaP-in}
  \inferrule{
  	\ue=\auanain{\ell}{\ue'}\\
  	e=\aein{\labelset, \ell}{\ell}{\mapschema{\tau}{i}{\labelset}; \mapitem{\ell}{\tau}}{e'}\\\\
    \eanaPX{\ue'}{e'}{\tau}
  }{
  	\eanaPX{\ue}{e}{ \asum{\labelset, \ell}{\mapschema{\tau}{i}{\labelset}; \mapitem{\ell}{\tau}}}
    % \uOmega \vdash_{\uPsi; \uPhi} \left(\shortstack{$\ue \leadsto $\\$\Leftarrow$\vspace{-1.2em}}\right)
    %\eanaPX{\auanain{\ell}{\ue}}{\aein{\labelset, \ell}{\ell}{\mapschema{\tau}{i}{\labelset}; \mapitem{\ell}{\tau}}{e}}{\asum{\labelset, \ell}{\mapschema{\tau}{i}{\labelset}; \mapitem{\ell}{\tau}}}
  }
\end{equation}

% Rule (\ref{rule:esyn-match}) governed match expressions in synthetic position. The following rule governs match expressions in analytic position.
\begin{equation}\label{rule:eanaP-match}
  \inferrule{
    \esynPX{\ue}{e}{\tau}\\
    \{\ranaPX{\urv_i}{r_i}{\tau}{\tau'}\}_{1 \leq i \leq n}
  }{
    \eanaPX{\aumatchwithb{n}{\ue}{\seqschemaX{\urv}}}{\aematchwith{n}{\tau'}{e}{\seqschemaX{r}}}{\tau'}
  }
\end{equation}
\end{subequations}

\todo{revise the following}
\begin{subequations}[resume]
% Rule (\ref{rule:esyn-defuetsm}) governed ueTSM definitions in synthetic position. The following rule governs ueTSM definitions in analytic position.
\begin{equation}\label{rule:eanaP-defuetsm}
\inferrule{
  \expandsTU{\uDelta}{\utau}{\tau}\\
  \hastypeU{\emptyset}{\emptyset}{\eparse}{\aparr{\tBody}{\tParseResultExp}}\\\\
  \eana{\uDelta}{\uGamma}{\uPsi, \uShyp{\tsmv}{a}{\tau}{\eparse}}{\uPhi}{\ue}{e}{\tau'}
}{
  \eanaPX{\usyntaxueP{\tsmv}{\utau}{\eparse}{\ue}}{e}{\tau'}
}
\end{equation}

% Rule (\ref{rule:esyn-implicite}) governed ueTSM designations in synthetic position. The following rule governs ueTSM designations in analytic position.
\begin{equation}\label{rule:eanaP-implicite}
  \inferrule{
    \eana{\uDelta}{\uGamma}{\uASI{\uA \uplus \vExpands{\tsmv}{a}}{\Psi, \xuetsmbnd{a}{\tau}{\eparse}}{\uI \uplus \designate{\tau}{a}}}{\uPhi}{\ue}{e}{\tau'}
  }{
    \eana{\uDelta}{\uGamma}{\uASI{\uA \uplus \vExpands{\tsmv}{a}}{\Psi, \xuetsmbnd{a}{\tau}{\eparse}}{\uI}}{\uPhi}{\implicite{\tsmv}{\ue}}{e}{\tau'}
  }
\end{equation}

% An expression of unadorned literal form can appear only in analytic position. The following rule extracts the TSM designated at the type that the expression is being analyzed against from the TSM designation context in the ueTSM context and applies it implicitly, i.e. the premises correspond to those of Rule (\ref{rule:esyn-apuetsm}).
\begin{equation}\label{rule:eanaP-lit}
  \inferrule{
    \encodeBody{b}{\ebody}\\
    \evalU{\ap{\eparse}{\ebody}}{\inj{\lbltxt{Success}}{\ecand}}\\
    \decodeCondE{\ecand}{\ce}\\\\
    \cana{\emptyset}{\emptyset}{\esceneUP{\uDelta}{\uGamma}{\uASI{\uA}{\Psi, \xuetsmbnd{a}{\tau}{\eparse}}{\uI \uplus \designate{\tau}{a}}}{\uPhi}{b}}{\ce}{e}{\tau}
  }{
    \eana{\uDelta}{\uGamma}{\uASI{\uA}{\Psi, \xuetsmbnd{a}{\tau}{\eparse}}{\uI \uplus \designate{\tau}{a}}}{\uPhi}{\auelit{b}}{e}{\tau}
  }
\end{equation}

% Rule (\ref{rule:esyn-defuptsm}) governed upTSM definitions in synthetic position. The following rule governs upTSM definitions in analytic position.
\begin{equation}\label{rule:eanaP-defuptsm}
\inferrule{
  \expandsTU{\uDelta}{\utau}{\tau}\\
  \hastypeU{\emptyset}{\emptyset}{\eparse}{\aparr{\tBody}{\tParseResultPat}}\\\\
  \eana{\uDelta}{\uGamma}{\uPsi}{\uPhi, \uPhyp{\tsmv}{a}{\tau}{\eparse}}{\ue}{e}{\tau'}
}{
  \eanaPX{\usyntaxup{\tsmv}{\utau}{\eparse}{\ue}}{e}{\tau'}
}
\end{equation}

% Rule (\ref{rule:esyn-implicitp}) governed upTSM designations in synthetic position. The following rule governs upTSM designations in analytic position.
\begin{equation}\label{rule:eanaP-implicitp}
  \inferrule{
    \eana{\uDelta}{\uGamma}{\uPsi}{\uASI{\uA\uplus\vExpands{\tsmv}{a}}{\Phi, \xuptsmbnd{a}{\tau}{\eparse}}{\uI \uplus \designate{\tau}{a}}}{\ue}{e}{\tau'}
  }{
    \eana{\uDelta}{\uGamma}{\uPsi}{\uASI{\uA\uplus\vExpands{\tsmv}{a}}{\Phi, \xuetsmbnd{a}{\tau}{\eparse}}{\uI}}{\implicitp{\tsmv}{\ue}}{e}{\tau'}
  }
\end{equation}

\end{subequations}

Synthetic rule expansion
%The synthetic typed rule expansion judgement is invoked iteratively by Rule (\ref{rule:esyn-match}) to synthesize a type, $\tau'$, from the branch expressions in the rule sequence. This judgement is defined mutually inductively with Rules (\ref{rules:esyn}) and Rules (\ref{rules:eana}) by the following rule. 
\begin{equation}\label{rule:rsynP}
  \inferrule{
  	\uOmega=\uOmegaEx{\uD}{\uG}{\uMctx}{\Omega}\\
    \patExpandsP{\uOmegaEx{\emptyset}{\uG'}{\emptyset}{\Omega'}}{\uPhi}{\upv}{p}{\tau}\\
    \esynP{\uOmegaEx{\uD}{\uG \uplus \uG'}{\uMctx}{\Omega \cup \Omega'}}{\uPsi}{\uPhi}{\ue}{e}{\tau'}
  }{
    \rsynP{\uOmega}{\uPsi}{\uPhi}{\aumatchrule{\upv}{\ue}}{\aematchrule{p}{e}}{\tau}{\tau'}
  }
\end{equation}

Analytic rule expansion
%The analytic typed rule expansion judgement is invoked iteratively by Rule (\ref{rule:eana-match}). This judgement is defined mutually inductively with Rules (\ref{rules:esyn}), Rules (\ref{rules:eana}), and Rule (\ref{rule:rsyn}) by the following rule, which is the analytic analag of Rule (\ref{rule:rsyn}).
\begin{equation}\label{rule:ranaP}
  \inferrule{
  	\uOmega=\uOmegaEx{\uD}{\uG}{\uMctx}{\Omega}\\
    \patExpandsP{\uOmegaEx{\emptyset}{\uG'}{\emptyset}{\Omega'}}{\uPhi}{\upv}{p}{\tau}\\
    \eanaP{\uOmegaEx{\uD}{\uG \uplus \uG'}{\uMctx}{\Omega \cup \Omega'}}{\uPsi}{\uPhi}{\ue}{e}{\tau'}
  }{
    \ranaP{\uOmega}{\uPsi}{\uPhi}{\aumatchrule{\upv}{\ue}}{\aematchrule{p}{e}}{\tau}{\tau'}
  }
\end{equation}

%The premises of these rules can be understood as described in Sec. \ref{sec:typed-expansion-UP}.% We will define typed pattern expansion below.

Typed pattern expansion
% The typed pattern expansion judgement is inductively defined by Rules (\ref{rules:patExpandsP}) as follows. %As in $\miniVersePat$, \emph{unexpanded pattern typing contexts}, $\upctx$, are defined identically to unexpanded typing contexts (i.e. we only use a distinct metavariable to emphasize their distinct roles in the judgements above). 

% The following rules are written identically to the typed pattern expansion rules for shared pattern forms in $\miniVersePat$, i.e. Rules (\ref{rule:patExpands-var}) through (\ref{rule:patExpands-in}).
\begin{subequations}\label{rules:patExpandsP}
\begin{equation}\label{rule:patExpandsP-var}
\inferrule{ }{
  \patExpandsP{\uOmegaEx{\emptyset}{\vExpands{\ux}{x}}{\emptyset}{\Ghyp{x}{\tau}}}{\uPhi}{\ux}{x}{\tau}
}
\end{equation}
\begin{equation}\label{rule:patExpandsP-wild}
\inferrule{ }{
  \patExpandsP{\uOmegaEx{\emptyset}{\emptyset}{\emptyset}{\emptyset}}{\uPhi}{\auwildp}{\aewildp}{\tau}
}
\end{equation}
\begin{equation}\label{rule:patExpandsP-fold}
\inferrule{ 
  \patExpandsP{\uOmega}{\uPhi}{\upv}{p}{[\arec{t}{\tau}/t]\tau}
}{
  \patExpandsP{\uOmega}{\uPhi}{\aufoldp{\upv}}{\aefoldp{p}}{\arec{t}{\tau}}
}
\end{equation}
\begin{equation}\label{rule:patExpandsP-tpl}
\inferrule{
	\upv=\autplp{\labelset}{\mapschema{\upv}{i}{\labelset}}\\
	p=\aetplp{\labelset}{\mapschema{p}{i}{\labelset}}\\\\
  \{\patExpandsP{{\uOmega_i}}{\uPhi}{\upv_i}{p_i}{\tau_i}\}_{i \in \labelset}
}{
	%\patExpandsP{\Gconsi{i \in \labelset}{\upctx_i}}{A}{B}{C}
	\patExpandsP{\Gconsi{i \in \labelset}{\uOmega_i}}{\uPhi}{\upv}{p}{\aprod{\labelset}{\mapschema{\tau}{i}{\labelset}}}
  % \patExpands{\Gconsi{i \in \labelset}{\pctx_i}}{\Phi}{
  %   \autplp{\labelset}{\mapschema{\upv}{i}{\labelset}}
  % }{
  %   \aetplp{\labelset}{\mapschema{p}{i}{\labelset}}
  % }{
  %   \aprod{\labelset}{\mapschema{\tau}{i}{\labelset}}
  % } %{\autplp{\labelset}{\mapschema{\upv}{i}{\labelset}}}{\aetplp{\labelset}{\mapschema}{p}{i}{\labelset}}{...}
  %\left(\shortstack{$\Delta \vdash_{\uPhi} \autplp{\labelset}{\mapschema{\upv}{i}{\labelset}}$\\$\leadsto$\\$\aetplp{\labelset}{\mapschema{p}{i}{\labelset}} : \aprod{\labelset}{\mapschema{\tau}{i}{\labelset}} \dashV \Gconsi{i \in \labelset}{\upctx_i}$\vspace{-1.2em}}\right)
}
\end{equation}
\begin{equation}\label{rule:patExpandsP-in}
\inferrule{
  \patExpandsP{\uOmega}{\uPhi}{\upv}{p}{\tau}
}{
  \patExpandsP{\uOmega}{\uPhi}{\auinjp{\ell}{\upv}}{\aeinjp{\ell}{p}}{\asum{\labelset, \ell}{\mapschema{\tau}{i}{\labelset}; \mapitem{\ell}{\tau}}}
}
\end{equation}
\todo{revise these}
The following rule governs upTSM application. It is written identically to Rule (\ref{rule:patExpands-apuptsm}).
\begin{equation}\label{rule:patExpandsP-apuptsm}
\inferrule{
  \encodeBody{b}{\ebody}\\
  \evalU{\ap{\eparse}{\ebody}}{\inj{\lbltxt{Success}}{\ecand}}\\
  \decodeCEPat{\ecand}{\cpv}\\\\
  \cvalidP{\uOmega}{\pscene{\Delta}{\uPhi, \uPhyp{\tsmv}{a}{\tau}{\eparse}}{b}}{\cpv}{p}{\tau}
}{
  \patExpands{\uOmega}{\uPhi, \uPhyp{\tsmv}{a}{\tau}{\eparse}}{\utsmap{\tsmv}{b}}{p}{\tau}
}
\end{equation}

Unexpanded patterns of unadorned literal form are governed by the following rule, which extracts the designated upTSM from the upTSM context and applies it implicitly, i.e. the premises correspond to those of Rule (\ref{rule:patExpandsP-apuptsm}).
\begin{equation}\label{rule:patExpandsP-lit}
\inferrule{
  \encodeBody{b}{\ebody}\\
  \evalU{\ap{\eparse}{\ebody}}{\inj{\lbltxt{Success}}{\ecand}}\\
  \decodeCEPat{\ecand}{\cpv}\\\\
  \cvalidP{\uOmega}{\pscene{\Delta}{\uASI{\uA}{\Phi, \xuptsmbnd{a}{\tau}{\eparse}}{\uI, \designate{\tau}{a}}}{b}}{\cpv}{p}{\tau}
}{
  \patExpands{\uOmega}{\uASI{\uA}{\Phi, \xuptsmbnd{a}{\tau}{\eparse}}{\uI, \designate{\tau}{a}}}{\lit{b}}{p}{\tau}
}
\end{equation}

\end{subequations}


\subsubsection{Unexpanded Signatures and Module Expressions}
\todo{do these}

\subsubsection{TSM Types and Expressions}
\todo{judgement listing}
TSM type formation
\begin{subequations}\label{rules:istsmty}
\begin{equation}\label{rule:istsmty-type}
\inferrule{
	\istypePX{\tau}
}{
	\istsmty{\Omega}{\aetype{\tau}}
}
\end{equation}
\begin{equation}\label{rule:istsmty-alltypes}
\inferrule{
	\istsmty{\Omega, t :: \akty}{\rho}
}{
	\istsmty{\Omega}{\aealltypes{t}{\rho}}
}
\end{equation}
\begin{equation}\label{rule:istsmty-allmods}
\inferrule{
	\issig{\Omega}{\sigma}\\
	\istsmty{\Omega, X : \sigma}{\rho}
}{
	\istsmty{\Omega}{\aeallmods{\sigma}{X}{\rho}}
}
\end{equation}
\end{subequations}

Unexpanded TSM type expansion
\begin{subequations}\label{rules:tsmtyExpands}
\begin{equation}\label{rule:tsmtyExpands-type}
\inferrule{
	\tExpandsPX{\utau}{\tau}
}{
	\tsmtyExpands{\uOmega}{\autype{\utau}}{\aetype{\tau}}
}
\end{equation}
\begin{equation}\label{rule:tsmtyExpands-alltypes}
\inferrule{
	\tsmtyExpands{\uOmega, \uKhyp{\ut}{t}{\akty}}{\urho}{\rho}
}{
	\tsmtyExpands{\uOmega}{\aualltypes{\ut}{\urho}}{\aealltypes{t}{\rho}}
}
\end{equation}
\begin{equation}\label{rule:tsmtyExpands-allmods}
\inferrule{
	\sigExpandsPX{\usigma}{\sigma}\\
	\tsmtyExpands{\uOmega, \uMhyp{\uX}{X}{\sigma}}{\urho}{\rho}
}{
	\tsmtyExpands{\uOmega}{\auallmods{\usigma}{\uX}{\urho}}{\aeallmods{\sigma}{X}{\rho}}
}
\end{equation}
\end{subequations}

\subsection{Metatheory}

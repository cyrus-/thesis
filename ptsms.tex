% !TEX root = omar-thesis.tex

\chapter{Parameterized TSMs}\label{chap:ptsms}
\section{Parameterized TSMs By Example}
\subsection{Type Parameters By Example}
\begin{lstlisting}[numbers=none]
syntax $list('a :: Type) at 'a list {
  static fn(body : Body) => (* ... *)
}
val example = $list int [1, 2, 3]

\end{lstlisting}

\begin{lstlisting}[numbers=none]
implicit syntax $list 'a at 'a list forall 'a :: Type in
	val example : int list = [1, 2, 3]
end
\end{lstlisting}
\begin{lstlisting}[numbers=none]
implicit syntax $list 'a at 'a list in
	val example : int list = [1, 2, 3]
end
\end{lstlisting}
\subsection{Module Parameters By Example}
\section{\texorpdfstring{$\miniVerseParam$}{miniVerseForall}}
\subsection{Syntax of the Inner Language}

\begin{figure}[p] 
$\begin{array}{lllllll}
\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\mathsf{Kind} & \kappa & ::= & \akty & \kty & \text{types}\\
&&& \aksing{c} & \ksing{c} & \text{singleton}\\
&&& \akdarr{\kappa}{u}{\kappa} & \kdarr{u}{\kappa}{\kappa} & \text{dependent function}\\
&&& \akunit & \kunit & \text{nullary product}\\
&&& \akdprod{\kappa}{u}{\kappa} & \kdprod{u}{\kappa}{\kappa} & \text{dependent product}\\
\mathsf{Con} & c & ::= & u & u & \text{variable}\\
%\mathsf{Typ} & \tau & ::= & t & t & \text{variable}\\
&&& \aparr{c}{c} & \parr{c}{c} & \text{partial function}\\
&&& \aallu{\kappa}{u}{c} & \forallu{u}{\kappa}{c} & \text{polymorphic}\\
&&& \arecu{\kappa}{u}{c} & \recu{u}{\kappa}{c} & \text{recursive}\\
&&& \aprod{\labelset}{\mapschema{c}{i}{\labelset}} & \prodt{\mapschema{c}{i}{\labelset}} & \text{labeled product}\\
&&& \asum{\labelset}{\mapschema{c}{i}{\labelset}} & \sumt{\mapschema{c}{i}{\labelset}} & \text{labeled sum}\\
% \mathsf{Exp} & e & ::= & x & x & \text{variable}\\
% &&& \aelam{\tau}{x}{e} & \lam{x}{\tau}{e} & \text{abstraction}\\
% &&& \aeap{e}{e} & \ap{e}{e} & \text{application}\\
% &&& \aetlam{t}{e} & \Lam{t}{e} & \text{type abstraction}\\
% &&& \aetap{e}{\tau} & \App{e}{\tau} & \text{type application}\\
% &&& \aefold{t}{\tau}{e} & \fold{e} & \text{fold}\\
% &&& \aeunfold{e} & \unfold{e} & \text{unfold}\\
% &&& \aetpl{\labelset}{\mapschema{e}{i}{\labelset}} & \tpl{\mapschema{e}{i}{\labelset}} & \text{labeled tuple}\\
% &&& \aepr{\ell}{e} & \prj{e}{\ell} & \text{projection}\\
% &&& \aein{\labelset}{\ell}{\mapschema{\tau}{i}{\labelset}}{e} & \inj{\ell}{e} & \text{injection}\\
% \LCC \lightgray & \lightgray & \lightgray & \lightgray & \lightgray & \lightgray \\
% &&& \aematchwith{n}{\tau}{e}{\seqschemaX{r}} & \matchwith{e}{\seqschemaX{r}} & \text{match}\\
% \mathsf{ERule} & r & ::= & \aematchrule{p}{e} & \matchrule{p}{e} & \text{rule}\\
% \mathsf{EPat} & p & ::= & x & x & \text{variable pattern}\\
% &&& \aewildp & \wildp & \text{wildcard pattern}\\
% &&& \aefoldp{p} & \foldp{p} & \text{fold pattern}\\
% &&& \aetplp{\labelset}{\mapschema{p}{i}{\labelset}} & \tplp{\mapschema{p}{i}{\labelset}} & \text{labeled tuple pattern}\\
% &&& \aeinjp{\ell}{p} & \injp{\ell}{p} & \text{injection pattern}\ECC
\end{array}$
\caption[Syntax of kinds and constructors in $\miniVerseParam$]{Syntax of kinds and constructors in $\miniVerseParam$. We adopt the metatheoretic conventions established for our specification of $\miniVerseUE$ in Sec. \ref{sec:miniVerseU} and $\miniVersePat$ in Sec. \ref{sec:miniVerseUP} without restating them. Kinds and constructors are identified up to $\alpha$-equivalence.}
\label{fig:P-kinds-constructors}
\end{figure}

\subsubsection{Syntax of the Inner Core Language}
\todo{do this}
\subsubsection{Syntax of the Inner Module Language}
\todo{do this}
\subsection{Statics of the Inner Language}
\todo{do this}
\subsubsection{Kinds, Constructors and Types}
\todo{do this}
\subsubsection{Expanded Expressions}
\todo{do this}
\subsubsection{Signatures and Structures}
\todo{do this}
\subsection{Structural Dynamics}
\todo{do this}
\subsection{Syntax of the Surface Language}
\todo{do this}
\subsubsection{Syntax of the Surface Core Language}
\todo{do this}
\subsubsection{Syntax of the Expression TSM Language}
\todo{do this}
\subsubsection{Syntax of the Pattern TSM Language}
\todo{do this}
\subsubsection{Syntax of Type Patterns}
\todo{do this}
\subsubsection{Syntax of the Surface Module Language}
\todo{do this}

\subsection{Typed Expansion}
\subsection{Metatheory}

\section{pTSLs By Example}
For example, a module \lstinline{P} can associate the TSM \lstinline{rx} defined in the previous section with the abstract type \lstinline{R.t} by qualifying the definition of the sealed module it is defined by as follows:
\begin{lstlisting}[numbers=none]
module R = mod {
  type t = (* ... *)
  (* ... *)
} :> RX with syntax rx
\end{lstlisting}
More generally, when sealing a module expression against a signature, the programmer can specify, for each abstract type that is generated, at most one previously defined TSMs. This TSM must take as its first parameter the module being sealed.

The following function has the same expansion as \lstinline{example_using_tsm} but, by using the TSL just defined, it is more concise. Notice the return type annotation, which is necessary to ensure that the TSL can be unambiguously determined:
\begin{lstlisting}[numbers=none]
fun example_using_tsl(name : string) : R.t => /SURL@EURLnameSURL: %EURLssn/
\end{lstlisting}

As another example, let us consider the standard list datatype. We can use TSLs to express derived list syntax, for both expressions and patterns:
\begin{lstlisting}[numbers=none]
datatype list('a) { Nil | Cons of 'a * list('a) } with syntax {
  static fn (body : Body) => 
    (* ... comma-delimited spliced exps ... *)
} with pattern syntax {
  static fn (body : Body) : Pat => 
    (* ... list pattern parser ... *)
}
\end{lstlisting}
Together with the TSL for regular expression patterns, this allows us to write lists like this:
\begin{lstlisting}[numbers=none]
let val x : list(R.t) = [/SURL\dEURL/SHTML, EHTML/SURL\d\dEURL/SHTML, EHTML/SURL\d\d\dEURL/]
\end{lstlisting}
From the client's perspective, it is essentially as if the language had built in derived syntax for lists and regular expression patterns directly.%However, we did not need to build in this syntax primitively.%The only constraint is that this syntax must be used in an analytic position, which we argue is actually better for code compren when encountering unfamiliar syntax.

\section{Parameterized Modules}
TSLs can be associated with abstract types that are generated by parameterized modules (i.e. generative functors in Standard ML) as well. For example, consider a trivially parameterized module that creates modules sealed against \lstinline{RX}:
\begin{lstlisting}[numbers=none]
module F() => mod {
  type t = (* ... *)
  (* ... *)
} :> RX with syntax rx 
\end{lstlisting}
Each application of \lstinline{F} generates a distinct abstract type. The semantics associates the appropriately parameterized TSM with each of these as they are generated:
\begin{lstlisting}[numbers=none]
module F1 = F() (* F1.t has TSL rx(F1) *)
module F2 = F() (* F2.t has TSL rx(F2) *)
\end{lstlisting}

As a more complex example, let us define two signatures, \lstinline{A} and \lstinline{B}, a TSM \texttt{\$G} and a parameterized module \lstinline{G : A -> B}:
\begin{lstlisting}[numbers=none,mathescape=|]
signature A = sig { type t; val x : t }
signature B = sig { type u; val y : u }
syntax $G(M : A)(G : B) at G.u { (* ... *) }
module G(M : A) => mod { 
  type u = M.t; val y = M.x } :> B with syntax $G(M)
\end{lstlisting}
Both \lstinline{G} and \texttt{\$G} take a parameter \lstinline{M : A}. We associate the partially applied TSM \texttt{\$G(M)} with the abstract type that \lstinline{G} generates. Again, this satisfies the requirement that one must be able to apply the TSM being associated with the abstract type to the module being sealed. 

Only fully abstract types can have TSLs associated with them. Within the definition of \lstinline{G}, type \lstinline{u} does not have a TSL available to it because it is synonymous to \lstinline{M.t}. More generally, TSL lookup respects type equality, so any synonyms of a type with a TSL will also have that TSL. We can see this in the following example, where the type \lstinline{u} has a different TSL associated with it inside and outside the definition of the module \lstinline{N}:
\begin{lstlisting}[numbers=none,mathescape=|]
module M : A = mod { type t = int; val x = 0 }
module G1 = G(M) (* G1.t has TSL $G(M), per above *)
module N = mod { 
  type u = G1.t (* u = G1.t in this scope, so u also has TSL $G(M) *)
  val y = /asdf/ (* we can use it to create a value of that type *) 
} :> B (* did not specify a TSL for N.u at the point where it is sealed, 
            so N.u has no TSL in the outer scope *)
val z : N.u = /asdf/ (* ERROR: no TSL for type N.u *)
\end{lstlisting}

\section{\texorpdfstring{$\miniVerseTSL$}{miniVerseTSL}}
A formal specification of TSLs in a language that supports only non-parametric datatypes is available in a paper published in ECOOP 2014 \cite{TSLs}. %We will add support for parameterized TSLs in the dissertation (see Sec. %\ref{sec:syntax-timeline}).

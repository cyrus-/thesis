% !TEX root = omar-thesis.tex
\chapter{Unparameterized TSM Implicits}\label{chap:tsls}
Using TSMs, a library provider can control the expansion of generalized literal forms. However, the library client must explicitly prefix each such form with a TSM name. To further lower the syntactic cost of using TSMs, so that it compares to the syntactic cost of using derived forms built primitively into a language, VerseML allows clients to designate, for any type, one TSM as that type's \emph{implicit TSM} within a delimited scope. When VerseML's \emph{local type inference} system encounters a generalized literal form not prefixed by a TSM name (an \emph{unadorned literal form}), it applies the TSM associated with the type that the expression or pattern is being checked against.

\section{TSM Implicits By Example}\label{sec:tsm-implicits-by-example}
We begin in this section by introducing TSM implicits by example in VerseML. In Sec. \ref{sec:b-miniverse}, we will formalize TSM implicits with a reduced calculus, {Bidirectional} $\miniVersePat$. 

\subsection{Designation and Usage}
In the following example, the expression TSM named \li{#\dolla#rx}, defined in Section \ref{sec:uetsms-definition}, is designated the implicit expression TSM at type \li{Rx}, and the pattern TSM named \li{#\dolla#rx}, defined in Sec. \ref{sec:ptsms-definition}, is designated the implicit pattern TSM at type \li{Rx},  both within the indicated scope.  %The scope of this declaration could be further restricted using the clauses shown in comments below. 
\begin{lstlisting}
implicit syntax 
  $rx at Rx for expressions
  $rx at Rx for patterns
in
  fun is_ssn(s : string) => rx_match /SURL\d\d\d-\d\d-\d\d\d\dEURL/ s
  fun name_from_example_rx(r : Rx) : string option => 
    match r with 
      /SURL@EURLnameSURL: %EURL_/ => Some name
    | _ => None
end
\end{lstlisting}
For convenience, VerseML also provides a derived designation form that combines the two designations above:
\begin{lstlisting}[numbers=none]
implicit syntax 
  $rx at Rx 
in 
  (* ... *)
end 
\end{lstlisting}

On Line 5 of the example above, we apply a function \li{rx_match} (not shown), which has type \li{Rx -> string -> MatchResult}, to an expression of unadorned literal form. The expression TSM \li{#\dolla#rx} is applied implicitly to this expression to determine its expansion because the expression appears in a syntactic position where it must be of type \li{Rx}, and we have designated \li{#\dolla#rx} as the implicit expression TSM at this type. %f we had instead applied it explicitly, Line 2 would be written as follows:
% \begin{lstlisting}[numbers=none]
% fun is_ssn(s : string) => rx_match ($rx /SURL\d\d\d-\d\d-\d\d\d\dEURL/) s
% \end{lstlisting}

Similarly, a pattern of unadorned literal form appears on Line 8. Because it appears in a syntactic position where it must match values of type \li{Rx}, the pattern TSM \li{#\dolla#rx} is implicitly applied to determine its expansion.

\subsection{Analytic and Synthetic Positions}
When typechecking a subexpression, $e'$, of an expresssion, $e$, we say that $e'$ appears in an \emph{analytic position} if the type that $e'$ must have is fully determined by its position within $e$. For example, an expression appearing as a function argument is in an analytic position because the function's type determines each of the argument types. Similarly, an expression may be in analytic position due to a \emph{type ascription}, either directly on the expression, or on the binding or definition that the expression appears within:
\begin{lstlisting}[numbers=none]
val ssn = /SURL\d\d\d-\d\d-\d\d\d\dEURL/ : Rx
val ssn : Rx = /SURL\d\d\d-\d\d-\d\d\d\dEURL/
fun ssn() : Rx => /SURL\d\d\d-\d\d-\d\d\d\dEURL/
\end{lstlisting}

If the type of $e'$ is not fully determined by its position within $e$, we instead say that the expression appears in a \emph{synthetic position}. For example, a top-level expression, or an expression appearing in a binding or definition without a type ascription, appears in a synthetic position.

Expressions of unadorned literal form are only valid in analytic position, because their type must be known to be able to determine the appropriate TSM to implicitly apply. The following expressions cannot be typechecked because expressions of unadorned literal form appear in synthetic position:
\begin{lstlisting}[numbers=none]
let 
  val ssn = /SURL\d\d\d-\d\d-\d\d\d\dEURL/ (* INVALID *)
  fun ssn() => /SURL\d\d\d-\d\d-\d\d\d\dEURL/ (* INVALID *)
in 
  (* ... *) 
end
\end{lstlisting}

In VerseML, the scrutinee of a match expression is always in synthetic position. Consequently, the type of value that a pattern appearing within a match expression must match is always known, so patterns can always be of unadorned literal form.
\section{Bidirectional $\miniVersePat$}\label{sec:b-miniverse}
\subsection{Inner Core}
\subsection{Syntax of the Outer Surface}
\subsection{Bidirectionally Typed Expansion}
\subsection{uTSL Definition}
\subsection{uTSL Application}
\subsection{Candidate Expansion Validation}
